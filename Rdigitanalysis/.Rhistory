}
DigitData@max
DigitData@left_aligned_column_names
grab_desired_aligned_columns(DigitData, c("ALEXP", "BENTOT"), skip_first_figit=TRUE, last_digit_test_included=FALSE, align_direction='left')
lst = grab_desired_aligned_columns(DigitData, c("ALEXP", "BENTOT"), skip_first_figit=TRUE, last_digit_test_included=FALSE, align_direction='left')
data = lst$digits_table
DigitData = lst$digitdata
DigitData@max
head(data)
for (name in colnames(data)){
for (i in 1:length(DigitData@left_aligned_column_names)){
if (grepl(DigitData@left_aligned_column_names, name, fixed = TRUE)){
print(grepl(DigitData@left_aligned_column_names, name, fixed = TRUE))
}
}
}
colnames(data)
a=colnames(data)[1]
a
for (name in colnames(data)){
for (i in 1:length(DigitData@left_aligned_column_names)){
if (grepl(DigitData@left_aligned_column_names[i], name, fixed = TRUE)){
print(grepl(DigitData@left_aligned_column_names[i], name, fixed = TRUE))
}
}
}
for (name in colnames(data)){
for (i in 1:length(DigitData@left_aligned_column_names)){
if (grepl(DigitData@left_aligned_column_names[i], name, fixed = TRUE)){
print(i)
}
}
}
#intialize a table for storing total high and low digits counts for each digit place
high_and_low_total_counts = data.frame(matrix(nrow = 2, ncol = DigitData@max))
#name col and row
rownames(high_and_low_total_counts) = c('high digit counts', 'low digits counts')
colnames(high_and_low_total_counts) = DigitData@left_aligned_column_names[1:length(high_and_low_total_counts)]
high_and_low_total_counts
#intialize a table for storing total high and low digits counts for each digit place
high_and_low_total_counts = data.frame(matrix(nrow = 3, ncol = DigitData@max))
#name col and row
rownames(high_and_low_total_counts) = c('high digit counts', 'low digits counts', 'p value')
colnames(high_and_low_total_counts) = DigitData@left_aligned_column_names[1:length(high_and_low_total_counts)]
high_and_low_total_counts
#intialize a table for storing total high and low digits counts for each digit place
high_and_low_total_counts = data.frame(matrix(0, nrow = 3, ncol = DigitData@max))
#name col and row
rownames(high_and_low_total_counts) = c('high digit counts', 'low digits counts', 'p value')
colnames(high_and_low_total_counts) = DigitData@left_aligned_column_names[1:length(high_and_low_total_counts)]
high_and_low_total_counts
#intialize a table for storing total high and low digits counts for each digit place
high_and_low_total_counts = data.frame(matrix(0, nrow = 2, ncol = DigitData@max))
#name col and row
rownames(high_and_low_total_counts) = c('high digit counts', 'low digits counts')
colnames(high_and_low_total_counts) = DigitData@left_aligned_column_names[1:length(high_and_low_total_counts)]
high_and_low_total_counts
for (name in colnames(data)){
for (i in 1:length(DigitData@left_aligned_column_names)){
if (grepl(DigitData@left_aligned_column_names[i], name, fixed = TRUE)){
#i is the digit place of this column
print(i)
#get frequency of each digit in each digit place
counts_obs = table(data[name])
counts_obs = counts_obs[-omit_05]
#get total occurances of high digit places
high_counts_obs = sum(counts_obs[high])
low_counts_obs = sum(counts_obs) - high_counts_obs
#update counts table
high_and_low_total_counts[i] = high_and_low_total_counts[i] + c(high_counts_obs, low_counts_obs)
}
}
}
high_and_low_total_counts
skip_first_figit = TRUE
#intialize a table for storing total high and low digits counts for each digit place
high_and_low_total_counts = data.frame(matrix(0, nrow = 2, ncol = DigitData@max))
#name col and row
rownames(high_and_low_total_counts) = c('high digit counts', 'low digits counts')
colnames(high_and_low_total_counts) = DigitData@left_aligned_column_names[1:length(high_and_low_total_counts)]
high_and_low_total_counts
for (name in colnames(data)){
for (i in 1:length(DigitData@left_aligned_column_names)){
if (grepl(DigitData@left_aligned_column_names[i], name, fixed = TRUE)){
#i is the digit place of this column
print(i)
#get frequency of each digit in each digit place
counts_obs = table(data[name])
counts_obs = counts_obs[-omit_05]
print(counts_obs)
#get total occurances of high digit places
high_counts_obs = sum(counts_obs[high])
low_counts_obs = sum(counts_obs) - high_counts_obs
print(high_counts_obs)
print(low_counts_obs)
#update counts table
high_and_low_total_counts[i] = high_and_low_total_counts[i] + c(high_counts_obs, low_counts_obs)
}
}
}
data = single_column_aligned(DigitData, "ALEXP", 'left')
#i is the ith digit place always since it is from the left
for (i in 1:length(data)){
#get frequency of each digit in each digit place
counts_obs = table(data[i])
counts_obs = counts_obs[-omit_05]
#get total occurances of high digit places
high_counts_obs = sum(counts_obs[high], na.rm = TRUE)
total_counts_obs = sum(counts_obs)
#get p_value from binomial test
p_value = binom.test(c(high_counts_obs, total_counts_obs-high_counts_obs), p = high_freq_theoratical[i])$p.value
print(p_value)
}
for (name in colnames(data)){
for (i in 1:length(DigitData@left_aligned_column_names)){
if (grepl(DigitData@left_aligned_column_names[i], name, fixed = TRUE)){
#i is the digit place of this column
print(i)
#get frequency of each digit in each digit place
counts_obs = table(data[name])
counts_obs = counts_obs[-omit_05]
print(counts_obs)
#get total occurances of high digit places
high_counts_obs = sum(counts_obs[high], na.rm = TRUE)
low_counts_obs = sum(counts_obs) - high_counts_obs
print(high_counts_obs)
print(low_counts_obs)
#update counts table
high_and_low_total_counts[i] = high_and_low_total_counts[i] + c(high_counts_obs, low_counts_obs)
}
}
}
if (skip_first_figit){
high_and_low_total_counts = high_and_low_total_counts[-1]
}
high_and_low_total_counts
high_freq_theoratical
#get the data columns desired
lst = grab_desired_aligned_columns(DigitData, c("ALEXP", "BENTOT"), skip_first_figit=TRUE, last_digit_test_included=FALSE, align_direction='left')
data = lst$digits_table
DigitData = lst$digitdata
head(data)
#intialize a table for storing total high and low digits counts for each digit place
high_and_low_total_counts = data.frame(matrix(0, nrow = 2, ncol = DigitData@max))
#name col and row
rownames(high_and_low_total_counts) = c('high digit counts', 'low digits counts')
colnames(high_and_low_total_counts) = DigitData@left_aligned_column_names[1:length(high_and_low_total_counts)]
high_and_low_total_counts
for (name in colnames(data)){
for (i in 1:length(DigitData@left_aligned_column_names)){
if (grepl(DigitData@left_aligned_column_names[i], name, fixed = TRUE)){
#i is the digit place of this column
print(i)
#get frequency of each digit in each digit place
counts_obs = table(data[name])
counts_obs = counts_obs[-omit_05]
print(counts_obs)
#get total occurances of high digit places
high_counts_obs = sum(counts_obs[high], na.rm = TRUE)
low_counts_obs = sum(counts_obs) - high_counts_obs
print(high_counts_obs)
print(low_counts_obs)
#update counts table
high_and_low_total_counts[i] = high_and_low_total_counts[i] + c(high_counts_obs, low_counts_obs)
}
}
}
high_and_low_total_counts
#intilaize p value table
p_values = data.frame(matrix(nrow = 1, ncol = 0))
for (i in 1:length(high_and_low_total_counts)){
#get p_value from binomial test
p_value = binom.test(high_and_low_total_counts[[i]], p = high_freq_theoratical[i])$p.value
#update
p_values[[colnames(high_and_low_total_counts)[i]]] = p_value
}
if (skip_first_figit){
p_values = p_values[-1]
}
p_values
break_by_category(data=DigitData@cleaned, break_out='YEAR')
DigitData@cleaned$YEAR
a= break_by_category(data=DigitData@cleaned, break_out='YEAR')
head(a)
a$`2006`
a$`2006`[1]
a$`2006`[103]
a$`2007`[103]
typeof(a$`2007`[103])
DigitData@cleaned$YEAR
a
a=list()
a[['x']]=c(1,2,43)
a
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
#force numerical representation rather than scientific
#options(scipen = 999)
options(scipen = 1)
options(digits = 2)
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data input functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford table functions.R')
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all digit test helper functions.R')
#load chi square test GOF functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\chi square goodness of fit functions.R')
#load main function for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all digit test main function.R')
#load all functions for digit pair test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\digit pair test.R')
#load all functions for rounding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\rounding test.R')
#load all functions for repeat test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\repeat test.R')
#compute the high low digit binomial test by digit place for desired data columns
#a helper function for the main function
high_low_by_digit_place = function(digitdata, data, skip_first_figit){
#intialize a table for storing total high and low digits counts for each digit place
high_and_low_total_counts = data.frame(matrix(0, nrow = 2, ncol = digitdata@max))
#name col and row for debug purpose
rownames(high_and_low_total_counts) = c('high digit counts', 'low digits counts')
colnames(high_and_low_total_counts) = digitdata@left_aligned_column_names[1:length(high_and_low_total_counts)]
#count high low digits in each column
for (name in colnames(data)){
for (i in 1:length(digitdata@left_aligned_column_names)){
if (grepl(digitdata@left_aligned_column_names[i], name, fixed = TRUE)){
#i is the digit place of this column
#get frequency of each digit in each digit place
counts_obs = table(data[name])
counts_obs = counts_obs[-omit_05]
#get total occurances of high digit places
high_counts_obs = sum(counts_obs[high], na.rm = TRUE)
low_counts_obs = sum(counts_obs) - high_counts_obs
#update counts table
high_and_low_total_counts[i] = high_and_low_total_counts[i] + c(high_counts_obs, low_counts_obs)
}
}
}
#intilaize p value table
p_values = data.frame(matrix(nrow = 1, ncol = 0))
#get p_value from binomial test
for (i in 1:length(high_and_low_total_counts)){
p_value = binom.test(high_and_low_total_counts[[i]], p = high_freq_theoratical[i])$p.value
p_values[[colnames(high_and_low_total_counts)[i]]] = p_value
}
#drop 1st digit place if this is true
if (skip_first_figit){
p_values = p_values[-1]
}
return(p_values)
}
high_low_test = function(digitdata, contingency_table, data_columns, skip_first_figit=TRUE, last_digit_test_included=FALSE, break_out=NA){
#get table for the theoratical high to low freqency in each digit place
#if omit_05 in high, then should throw error...no way should it be omiited and counted as highh digit
#drop X and Digits column of contingency table
high_freq_theoratical = contingency_table[!(colnames(contingency_table) %in% c('X', 'Digits'))]
#get the frequency for high digits in each digit place
high_freq_theoratical = t(data.frame(colSums(high_freq_theoratical[as.integer(high)+1,]))) #+1 since digit start at 0 but index start at 1
rownames(high_freq_theoratical) = 'high digits freq'
#get the data columns desired
lst = grab_desired_aligned_columns(digitdata, data_columns, skip_first_figit=skip_first_figit, last_digit_test_included=last_digit_test_included, align_direction='left')
data = lst$digits_table
digitdata = lst$digitdata
#perform a standard high low test
if (is.na(break_out)){
p_values = high_low_by_digit_place(digitdata, data, skip_first_figit)
rownames(p_values) = 'all'
return(p_values)
}
#perform a 'year effect' high low test break by category
else {
#initlaize a list to be returned
output = list()
#get indexes for each category
indexes_of_categories = break_by_category(data=digitdata@cleaned, break_out=break_out) #this is a list since unequal number of entries for each category
#break by category for all
for (category_name in names(indexes_of_categories)){
indexes_of_category = indexes_of_categories[[category_name]]
data_of_category = data.frame(data[indexes_of_category, ])
#get p_values for this category ('year')
p_values = high_low_by_digit_place(digitdata, data_of_category, skip_first_figit)
#update returning list
output[[category_name]] = p_values
}
return(output)
}
}
#test data input and benford table functions
#load data input functions
data_columns = c("ALEXP","BENTOT", "BENM", "BENF")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
contingency_table
high = c('6', '7', '8', '9')
omit_05 = c(0, 5)
skip_first_figit = TRUE
last_digit_test_included = FALSE
data_columns = c("ALEXP", "BENTOT")
break_out = 'YEAR'
high_low_test(DigitData, contingency_table, data_columns, skip_first_figit, last_digit_test_included, break_out)
#compute the high low digit binomial test by digit place for desired data columns
#a helper function for the main function
high_low_by_digit_place = function(digitdata, data, high_freq_theoratical, skip_first_figit){
#intialize a table for storing total high and low digits counts for each digit place
high_and_low_total_counts = data.frame(matrix(0, nrow = 2, ncol = digitdata@max))
#name col and row for debug purpose
rownames(high_and_low_total_counts) = c('high digit counts', 'low digits counts')
colnames(high_and_low_total_counts) = digitdata@left_aligned_column_names[1:length(high_and_low_total_counts)]
#count high low digits in each column
for (name in colnames(data)){
for (i in 1:length(digitdata@left_aligned_column_names)){
if (grepl(digitdata@left_aligned_column_names[i], name, fixed = TRUE)){
#i is the digit place of this column
#get frequency of each digit in each digit place
counts_obs = table(data[name])
counts_obs = counts_obs[-omit_05]
#get total occurances of high digit places
high_counts_obs = sum(counts_obs[high], na.rm = TRUE)
low_counts_obs = sum(counts_obs) - high_counts_obs
#update counts table
high_and_low_total_counts[i] = high_and_low_total_counts[i] + c(high_counts_obs, low_counts_obs)
}
}
}
#intilaize p value table
p_values = data.frame(matrix(nrow = 1, ncol = 0))
#get p_value from binomial test
for (i in 1:length(high_and_low_total_counts)){
p_value = binom.test(high_and_low_total_counts[[i]], p = high_freq_theoratical[i])$p.value
p_values[[colnames(high_and_low_total_counts)[i]]] = p_value
}
#drop 1st digit place if this is true
if (skip_first_figit){
p_values = p_values[-1]
}
return(p_values)
}
high_low_test(DigitData, contingency_table, data_columns, skip_first_figit, last_digit_test_included, break_out)
#compute the high low digit binomial test by digit place for desired data columns
#a helper function for the main function
high_low_by_digit_place = function(digitdata, data, high_freq_theoratical, skip_first_figit){
#intialize a table for storing total high and low digits counts for each digit place
high_and_low_total_counts = data.frame(matrix(0, nrow = 2, ncol = digitdata@max))
#name col and row for debug purpose
rownames(high_and_low_total_counts) = c('high digit counts', 'low digits counts')
colnames(high_and_low_total_counts) = digitdata@left_aligned_column_names[1:length(high_and_low_total_counts)]
#count high low digits in each column
for (name in colnames(data)){
for (i in 1:length(digitdata@left_aligned_column_names)){
if (grepl(digitdata@left_aligned_column_names[i], name, fixed = TRUE)){
#i is the digit place of this column
#get frequency of each digit in each digit place
counts_obs = table(data[name])
counts_obs = counts_obs[-omit_05]
#get total occurances of high digit places
high_counts_obs = sum(counts_obs[high], na.rm = TRUE)
low_counts_obs = sum(counts_obs) - high_counts_obs
#update counts table
high_and_low_total_counts[i] = high_and_low_total_counts[i] + c(high_counts_obs, low_counts_obs)
}
}
}
#intilaize p value table
p_values = data.frame(matrix(nrow = 1, ncol = 0))
#get p_value from binomial test
for (i in 1:length(high_and_low_total_counts)){
p_value = binom.test(high_and_low_total_counts[[i]], p = high_freq_theoratical[i])$p.value
p_values[[colnames(high_and_low_total_counts)[i]]] = p_value
}
#drop 1st digit place if this is true
if (skip_first_figit){
p_values = p_values[-1]
}
return(p_values)
}
high_low_test = function(digitdata, contingency_table, data_columns, skip_first_figit=TRUE, last_digit_test_included=FALSE, break_out=NA){
#get table for the theoratical high to low freqency in each digit place
#if omit_05 in high, then should throw error...no way should it be omiited and counted as highh digit
#drop X and Digits column of contingency table
high_freq_theoratical = contingency_table[!(colnames(contingency_table) %in% c('X', 'Digits'))]
#get the frequency for high digits in each digit place
high_freq_theoratical = t(data.frame(colSums(high_freq_theoratical[as.integer(high)+1,]))) #+1 since digit start at 0 but index start at 1
rownames(high_freq_theoratical) = 'high digits freq'
#get the data columns desired
lst = grab_desired_aligned_columns(digitdata, data_columns, skip_first_figit=skip_first_figit, last_digit_test_included=last_digit_test_included, align_direction='left')
data = lst$digits_table
digitdata = lst$digitdata
#perform a standard high low test
if (is.na(break_out)){
p_values = high_low_by_digit_place(digitdata, data, high_freq_theoratical, skip_first_figit)
rownames(p_values) = 'all'
return(p_values)
}
#perform a 'year effect' high low test break by category
else {
#initlaize a list to be returned
output = list()
#get indexes for each category
indexes_of_categories = break_by_category(data=digitdata@cleaned, break_out=break_out) #this is a list since unequal number of entries for each category
#break by category for all
for (category_name in names(indexes_of_categories)){
indexes_of_category = indexes_of_categories[[category_name]]
data_of_category = data.frame(data[indexes_of_category, ])
#get p_values for this category ('year')
p_values = high_low_by_digit_place(digitdata, data_of_category, high_freq_theoratical, skip_first_figit)
#update returning list
output[[category_name]] = p_values
}
return(output)
}
}
high_low_test(DigitData, contingency_table, data_columns, skip_first_figit, last_digit_test_included, break_out)
#compute the high low digit binomial test by digit place for desired data columns
#a helper function for the main function
high_low_by_digit_place = function(digitdata, data, high_freq_theoratical, skip_first_figit){
#intialize a table for storing total high and low digits counts for each digit place
high_and_low_total_counts = data.frame(matrix(0, nrow = 2, ncol = digitdata@max))
#name col and row for debug purpose
rownames(high_and_low_total_counts) = c('high digit counts', 'low digits counts')
colnames(high_and_low_total_counts) = digitdata@left_aligned_column_names[1:length(high_and_low_total_counts)]
#count high low digits in each column
for (name in colnames(data)){
for (i in 1:length(digitdata@left_aligned_column_names)){
if (grepl(digitdata@left_aligned_column_names[i], name, fixed = TRUE)){
#i is the digit place of this column
#get frequency of each digit in each digit place
counts_obs = table(data[name])
counts_obs = counts_obs[-omit_05]
#get total occurances of high digit places
high_counts_obs = sum(counts_obs[high], na.rm = TRUE)
low_counts_obs = sum(counts_obs) - high_counts_obs
#update counts table
high_and_low_total_counts[i] = high_and_low_total_counts[i] + c(high_counts_obs, low_counts_obs)
}
}
}
#intilaize p value table
p_values = data.frame(matrix(nrow = 1, ncol = 0))
#get p_value from binomial test
for (i in 1:length(high_and_low_total_counts)){
p_value = binom.test(high_and_low_total_counts[[i]], p = high_freq_theoratical[i])$p.value
print(high_and_low_total_counts[[i]])
print(high_freq_theoratical[i])
print(p_value)
p_values[[colnames(high_and_low_total_counts)[i]]] = p_value
}
#drop 1st digit place if this is true
if (skip_first_figit){
p_values = p_values[-1]
}
return(p_values)
}
high_low_test = function(digitdata, contingency_table, data_columns, skip_first_figit=TRUE, last_digit_test_included=FALSE, break_out=NA){
#get table for the theoratical high to low freqency in each digit place
#if omit_05 in high, then should throw error...no way should it be omiited and counted as highh digit
#drop X and Digits column of contingency table
high_freq_theoratical = contingency_table[!(colnames(contingency_table) %in% c('X', 'Digits'))]
#get the frequency for high digits in each digit place
high_freq_theoratical = t(data.frame(colSums(high_freq_theoratical[as.integer(high)+1,]))) #+1 since digit start at 0 but index start at 1
rownames(high_freq_theoratical) = 'high digits freq'
print(high_freq_theoratical)
#get the data columns desired
lst = grab_desired_aligned_columns(digitdata, data_columns, skip_first_figit=skip_first_figit, last_digit_test_included=last_digit_test_included, align_direction='left')
data = lst$digits_table
digitdata = lst$digitdata
#perform a standard high low test
if (is.na(break_out)){
p_values = high_low_by_digit_place(digitdata, data, high_freq_theoratical, skip_first_figit)
rownames(p_values) = 'all'
return(p_values)
}
#perform a 'year effect' high low test break by category
else {
#initlaize a list to be returned
output = list()
#get indexes for each category
indexes_of_categories = break_by_category(data=digitdata@cleaned, break_out=break_out) #this is a list since unequal number of entries for each category
#break by category for all
for (category_name in names(indexes_of_categories)){
indexes_of_category = indexes_of_categories[[category_name]]
data_of_category = data.frame(data[indexes_of_category, ])
#get p_values for this category ('year')
p_values = high_low_by_digit_place(digitdata, data_of_category, high_freq_theoratical, skip_first_figit)
#update returning list
output[[category_name]] = p_values
}
return(output)
}
}
high_low_test(DigitData, contingency_table, data_columns, skip_first_figit, last_digit_test_included, break_out)
source('C:/Users/happy/OneDrive - California Institute of Technology/Desktop/digitanalysis/Rdigitanalysis/R/Benford table functions.R', echo=TRUE)
#test high low test
data_columns = c("ALEXP", "BENTOT")
high = c(6,7,8,9)
omit_05 = c(0,5)
skip_first_figit = TRUE
last_digit_test_included = FALSE
break_out = 'YEAR'
#test high low test
data_columns = c("ALEXP", "BENTOT")
high = c(6,7,8,9)
omit_05 = c(0,5)
skip_first_figit = TRUE
last_digit_test_included = FALSE
break_out = 'YEAR'
high_low_test(DigitData, contingency_table, data_columns, high, omit_05, skip_first_figit, last_digit_test_included, break_out)
