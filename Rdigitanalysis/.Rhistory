observation_table = obtain_observation(digitdata, usable_data, digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
print("contingency_table")
print(contingency_table)
print("observation_table")
print(observation_table)
#######################################################################
#do chi square test
#######################################################################
df = get_df(contingency_table, standard = TRUE) ##############
print('degrees of freedom')
print(df)
#normal all digit test
if (is.na(unpacking_rounding_column)){
p_values = data.frame(all=chi_square_gof(observation_table, contingency_table, df))
##break on category if specified
if (!(is.na(break_out))){
#get indexes for each category
indexes_of_categories = break_by_category(digitdata@cleaned, break_out) #this is a list since unequal number of entries for each category
#breeak by category for all
for (category_name in names(indexes_of_categories)){
indexes_of_category = indexes_of_categories[[category_name]]
obs_in_category = obtain_observation(digitdata, usable_data[indexes_of_category, ], digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
p_values[category_name] = chi_square_gof(obs_in_category, contingency_table, df)
}
}
print('results')
print(p_values)
return(p_values)
}
##################################
##break on round unround
##perform unpack round digit test
else {
#intilaize a 2D table
p_values = data.frame(matrix(nrow = 2, ncol = 0))
rownames(p_values) = c('round', 'unround')
#unpack by round numbers indexes
round_numbers_indexes = unpacking_round_number_split(digitdata, unpacking_rounding_column)
p_values[unpacking_rounding_column] = NA
#perform chi square test on rounded rows
#[round_numbers_indexes, ]
obs_round = obtain_observation(digitdata, usable_data[round_numbers_indexes, ], digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
p_values[unpacking_rounding_column]['round', ] = chi_square_gof(obs_round, contingency_table, df)
#perform chi square test on unrounded rows
#[-round_numbers_indexes, ]
obs_unround = obtain_observation(digitdata, usable_data[-round_numbers_indexes, ], digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
p_values[unpacking_rounding_column]['unround', ] = chi_square_gof(obs_unround, contingency_table, df)
##############################
##break on category if specified, then also need to break by category on round and unround
if (!(is.na(break_out))){
#get indexes for each category
indexes_of_categories = break_by_category(digitdata@cleaned, break_out) #this is a list since unequal number of entries for each category
#breeak by category for round, and unround
for (category_name in names(indexes_of_categories)){
p_values[category_name] = NA
round_in_category_indexes = intersect(indexes_of_categories[[category_name]], round_numbers_indexes)
obs_round_in_category = obtain_observation(digitdata, usable_data[round_in_category_indexes, ], digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
p_values[category_name]['round', ] = chi_square_gof(obs_round_in_category, contingency_table, df)
unround_in_category_indexes = setdiff(indexes_of_categories[[category_name]], round_in_category_indexes)
obs_unround_in_category = obtain_observation(digitdata, usable_data[unround_in_category_indexes, ], digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
p_values[category_name]['unround', ] = chi_square_gof(obs_unround_in_category, contingency_table, df)
}
}
}
print('results')
print(p_values)
return(p_values)
}
data_columns = 'ALEXP'
result = all_digits_test(digitdata = DigitData, contingency_table = contingency_table, data_columns = data_columns, digit_places = digit_places, look_or_omit = look_or_omit,
skip_first_figit = skip_first_figit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE,
last_digit_test_included=FALSE, unpacking_rounding_column=unpacking_rounding_column)
data_columns = 'BENTOT'
result = all_digits_test(digitdata = DigitData, contingency_table = contingency_table, data_columns = data_columns, digit_places = digit_places, look_or_omit = look_or_omit,
skip_first_figit = skip_first_figit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE,
last_digit_test_included=FALSE, unpacking_rounding_column=unpacking_rounding_column)
############################################################
#Functions for digit analysis R package
###all digit test main function in this file
#Wenjun Chang
#Summer 2020
############################################################
############################################################
#all digits test
############################################################
################main function############
#performs all-digit place two-way chi square test vs Benfordâ€™s Law
#digitdata is the class object;
#data_columns are the names of numerical columns of data to be analyzed (defaulted as 'all' to the entire number table)
#digit_places are the indexes of digit places desired to test on
###can be single digit for single digit test, or an array of digits for multiple digit test
###-1 can only appear alone as for last digit test
###e.g. digit_places = 'all', 5, -1, c(1,2,3), etc.
#look_or_omit can be either 'look' or 'omit', to either omit or look exclusively at the digit_places specified
#omit_05 has three options: omit both 0 and 5->c(0,5); omit only 0->0 or c(0); and omit neither->NA (when no rounding test is performed)
#if analysis by groups is desired, break_out should specify the deisred category to break upon
#distribution can be 'Benford' or 'Uniform' or more ???
#if last_digit_test_included is true, will omit last digit before analysis, since we don't want tests to overlap
#unpacking_rounding_column specifies the data column (has to be numeric!) to split upon rounded
#and unrounded numbers to perform unpacking rounding test
#!!!last_digit_test_included should overwrite digit_places and (skip_first_digits)
all_digits_test = function(digitdata, contingency_table, data_columns='all', digit_places='all', look_or_omit='look',
skip_first_figit=TRUE, omit_05=c(0,5), break_out=NA, distribution='Benford', plot=TRUE,
last_digit_test_included=FALSE, unpacking_rounding_column=NA){
#############some logical stuff to check and throw errors on###########
#this must be multiple digits test
if ((digit_places != 'all') && (length(digit_places) > 1 )){
#thus should not have -1 as part of the array
if (!is.na(match(-1, digit_places))){
stop('multiple digits test cannot have last digit as part of the digit places')
}
}
if ((look_or_omit == 'look') && (skip_first_figit == TRUE)){
#should not have 1 as part of the array since we are skipping first digit place
if (!is.na(match(1, digit_places))){
stop('look_or_omit and skip_first_figit contradicts, both looking and not looking at the first digit place')
}
}
if (length(omit_05) == 1){
###check omit only 5, which is not allowed
if (!(is.na(omit_05)) && (omit_05 == 5)){
stop('cannot omit only 5 without also omitting 0 first')
}
}
if (length(digit_places) == 1){
#thus should not have -1 as part of the array
if (last_digit_test_included){
stop('not using any data')
}
if (skip_first_figit){
if (digit_places == 1){
stop('not using any data')
}
}
}
if (digit_places == 'all'){
if (look_or_omit == 'omit'){
stop('performing all digit tests on NO data!')
}
}
#######################################################################
#parse the data
#######################################################################
align_direction = 'left'
#get the digits of the desired data columns to be analyzed
lst = grab_desired_aligned_columns(digitdata, data_columns, skip_first_figit, last_digit_test_included, align_direction)
digitdata = lst$digitdata
digits_table = lst$digits_table
#get only the wanted digit places
if (digit_places == 'all'){
digit_places = seq(1, digitdata@max)
if (skip_first_figit){
digit_places = seq(2, digitdata@max)
}
}
usable_data = parse_digit_places(digitdata, digits_table, digit_places, look_or_omit)
#parse only needed parts of contingency table
contingency_table = parse_contigency_table(digitdata, contingency_table, digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
#get observation table from usable data
observation_table = obtain_observation(digitdata, usable_data, digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
print("contingency_table")
print(contingency_table)
print("observation_table")
print(observation_table)
#######################################################################
#do chi square test
#######################################################################
df = get_df(contingency_table)#, standard = TRUE) ##############
print('degrees of freedom')
print(df)
#normal all digit test
if (is.na(unpacking_rounding_column)){
p_values = data.frame(all=chi_square_gof(observation_table, contingency_table, df))
##break on category if specified
if (!(is.na(break_out))){
#get indexes for each category
indexes_of_categories = break_by_category(digitdata@cleaned, break_out) #this is a list since unequal number of entries for each category
#breeak by category for all
for (category_name in names(indexes_of_categories)){
indexes_of_category = indexes_of_categories[[category_name]]
obs_in_category = obtain_observation(digitdata, usable_data[indexes_of_category, ], digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
p_values[category_name] = chi_square_gof(obs_in_category, contingency_table, df)
}
}
print('results')
print(p_values)
return(p_values)
}
##################################
##break on round unround
##perform unpack round digit test
else {
#intilaize a 2D table
p_values = data.frame(matrix(nrow = 2, ncol = 0))
rownames(p_values) = c('round', 'unround')
#unpack by round numbers indexes
round_numbers_indexes = unpacking_round_number_split(digitdata, unpacking_rounding_column)
p_values[unpacking_rounding_column] = NA
#perform chi square test on rounded rows
#[round_numbers_indexes, ]
obs_round = obtain_observation(digitdata, usable_data[round_numbers_indexes, ], digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
p_values[unpacking_rounding_column]['round', ] = chi_square_gof(obs_round, contingency_table, df)
#perform chi square test on unrounded rows
#[-round_numbers_indexes, ]
obs_unround = obtain_observation(digitdata, usable_data[-round_numbers_indexes, ], digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
p_values[unpacking_rounding_column]['unround', ] = chi_square_gof(obs_unround, contingency_table, df)
##############################
##break on category if specified, then also need to break by category on round and unround
if (!(is.na(break_out))){
#get indexes for each category
indexes_of_categories = break_by_category(digitdata@cleaned, break_out) #this is a list since unequal number of entries for each category
#breeak by category for round, and unround
for (category_name in names(indexes_of_categories)){
p_values[category_name] = NA
round_in_category_indexes = intersect(indexes_of_categories[[category_name]], round_numbers_indexes)
obs_round_in_category = obtain_observation(digitdata, usable_data[round_in_category_indexes, ], digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
p_values[category_name]['round', ] = chi_square_gof(obs_round_in_category, contingency_table, df)
unround_in_category_indexes = setdiff(indexes_of_categories[[category_name]], round_in_category_indexes)
obs_unround_in_category = obtain_observation(digitdata, usable_data[unround_in_category_indexes, ], digit_places, look_or_omit, skip_first_figit, last_digit_test_included, omit_05)
p_values[category_name]['unround', ] = chi_square_gof(obs_unround_in_category, contingency_table, df)
}
}
}
print('results')
print(p_values)
return(p_values)
}
data_columns = 'ALEXP'
result = all_digits_test(digitdata = DigitData, contingency_table = contingency_table, data_columns = data_columns, digit_places = digit_places, look_or_omit = look_or_omit,
skip_first_figit = skip_first_figit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE,
last_digit_test_included=FALSE, unpacking_rounding_column=unpacking_rounding_column)
test2
############################################################
#Functions for digit analysis R package
###plotting helper functions
#Wenjun Chang
#Summer 2020
############################################################
############################################################
#helper function
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
#force numerical representation rather than scientific
#options(scipen = 999)
options(scipen = 1)
options(digits = 2)
##############################
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load chi square test GOF functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\chi_square_goodness_of_fit_functions.R')
#load main function for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_main_function.R')
#load all functions for digit pair test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\digit_pair_test.R')
#load all functions for rounding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\rounding_test.R')
#load all functions for repeat test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\repeat_test.R')
#load all functions for high low test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\high_low_test.R')
#load all functions for padding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\padding_test.R')
#############################################################
#############try it with given data##########################
#############################################################
#test data input and benford table functions
#load data input functions
data_columns = c("ALEXP","BENTOT", "BENM", "BENF")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
contingency_table
#data style can be only 'row' or 'column'
#row means the rows has the data
#defaulted to row cuz this is how the tests returns data
hist_2D = function(data, data_style='row'){
if (data_style == 'row'){
#transpose it to column style, what ggplot wants
data = data.frame(t(data))
}
plotting_data = data.frame(x=rownames(data), y=data)
colnames(plotting_data) = c('digit_places', 'p_values') #ensure col name are correct
print(plotting_data)
#2d plot
library(ggplot2)
hist2d = ggplot(data=plotting_data, aes(x=digit_places, y=p_values)) +
geom_bar(stat="identity")
#+ geom_text(aes(label=values), vjust=-0.3, size=3.5, color='blue') #for label exact value
return(hist2d)
}
hist_2D_variables = function(data, data_style='row'){
if (data_style == 'row'){
#transpose it to column style, what ggplot wants
data = data.frame(t(data))
}
#intialize a df for plotting, columns = x, y, category
plotting_data = data.frame(matrix(nrow = 0, ncol = 3))
colnames(plotting_data) = c('digit_places', 'p_values', 'category')
#fill up df
for (name in colnames(data)){
single_category_data = data.frame(digit_places=rownames(data), p_values=data[[name]], category=rep(name, nrow(data)))
plotting_data = rbind(plotting_data, single_category_data)
}
print(plotting_data)
#stacked 2d barplot with multiple groups
#use position=position_dodge()
library(ggplot2)
hist2d_multiple = ggplot(data=plotting_data, aes(x=digit_places, y=p_values, fill=category)) +
geom_bar(stat="identity", position=position_dodge()) + scale_x_discrete(limits=rownames(data)) #ensure order of digit places
#+ theme(legend.position="bottom") #legend position
return(hist2d_multiple)
}
#test plot
data_columns = c("ALEXP")#,"BENTOT", "BENM", "BENF")
max_length = 7
num_digits = 5
N = 10 #120k datasets took 15 mins
omit_05 = c(0,5)
break_out = NA#'DIST'
test=padding_test(DigitData, contingency_table, data_columns, max_length, num_digits, N, omit_05, break_out=NA)$diff_in_mean
hist_2D(test)
#2d with variables test
test2=padding_test(DigitData, contingency_table, data_columns, max_length, num_digits, N, omit_05, break_out="DIST")$diff_in_mean[1:3, ]
hist_2D_variables(test2)
test2
grid.arange()
require(gridExtra)
install.packages("gridExtra")
grid.arrange(a, b, nrow=1)
require(gridExtra)
grid.arrange(a, b, nrow=1)
a=hist_2D_variables(test2)
b=a
require(gridExtra)
grid.arrange(a, b, nrow=1)
grid.arrange(c(a,b), nrow=1)
qplot(a, b)
mydata <- data.frame(myGroup = c('a', 'b'), myX = c(1,1))
qplot(data = mydata,
x = myX,
facets = ~myGroup)
ggplot(data = mydata) +
geom_bar(aes(myX)) +
facet_wrap(~myGroup)
attach(mtcars)
par(mfrow=c(2,2))
attach(mtcars)
par(mfrow=c(2,2))
plots = c(a,b)
require(gridExtra)
n <- length(plots)
nCol <- floor(sqrt(n))
do.call("grid.arrange", c(plist, ncol=nCol))
do.call("grid.arrange", c(plots, ncol=nCol))
a
b
plots = list(a,b)
require(gridExtra)
n <- length(plots)
nCol <- floor(sqrt(n))
do.call("grid.arrange", c(plots, ncol=nCol))
do.call("grid.arrange", c(plots, nrow = nCol))
plots = list(a,b, c)
require(gridExtra)
do.call("grid.arrange", c(plots, nrow = floor(sqrt(length(plots)))))
c=a
plots = list(a,b, c)
require(gridExtra)
do.call("grid.arrange", c(plots, nrow = floor(sqrt(length(plots)))))
plots = list(a,b, c, c)
require(gridExtra)
do.call("grid.arrange", c(plots, nrow = floor(sqrt(length(plots)))))
plots = list(a,b, c, c, c, c, c, c)
require(gridExtra)
do.call("grid.arrange", c(plots, nrow = floor(sqrt(length(plots)))))
#plot_list is a list of plots desire to show
plot_multiple_hist2d = function(plot_list){
require(gridExtra)
plots = do.call("grid.arrange", c(plots, nrow = floor(sqrt(length(plots)))))
return(plots)
}
plot_multiple_hist2d(plots)
plots = list(a,b, c, c)
#plot_list is a list of plots desire to show
plot_multiple_hist2d = function(plot_list){
require(gridExtra)
plots = do.call("grid.arrange", c(plots, nrow = floor(sqrt(length(plots)))))
return(plots)
}
plot_multiple_hist2d(plots)
list(a)
a
a=list()
a
a=list(22323)
a
b=list(22323)
b
c(a,b)
test
a=data.frame(a)
a
a = c(1,2,4,7,6)
a=data.frame(a)
a
a['name'] = colnames(test)
a
p <- ggplot(a, aes(x=name, y = a))
p + geom_point()
a = c(1,2,5,3,4)
a=data.frame(a)
a['name'] = colnames(test)
a
p <- ggplot(a, aes(x=name, y = a))
p + geom_point()
p + geom_point() +geom_line()
p +geom_line()
p +geom_line()
p
print(p)
p <- ggplot(a, aes(x=name, y = a, group=1))
p +geom_line()
p=p +geom_line()
p
test=padding_test(DigitData, contingency_table, data_columns, max_length, num_digits, N, omit_05, break_out=NA)$diff_in_mean
s=hist_2D(test)
s
s+p
s + geom_point(data = a, aes(x = name, y = a, group=1))
s + geom_line(data = a, aes(x = name, y = a, group=1))
geom_line(data = a, aes(x = name, y = a, group=1))
a
a = c(1,2,5,3,4)
a
distribution_line(a)
#for making geom object for adding a Benford distribution line
distribution_line = function(distribution_data){
distribution_data = data.frame(distribution_data)
distribution_data['x'] = 1:nrow(distribution_data)
colnames(distribution_data) = c('expected', 'x')
return(geom_line(data = distribution_data, aes(x = x, y = expected, group=1)))
}
distribution_line(a)
s + geom_line(data = a, aes(x = name, y = a, group=1))
s + distribution_line(a)
test=padding_test(DigitData, contingency_table, data_columns, max_length, num_digits, N, omit_05, break_out=NA)$diff_in_mean
s=hist_2D(test)
test
mean(test)
mean(test)
mean(test[1])
rowMeans(test)
s+
mean(as.matrix(test))
#s+
mean(as.matrix(test))
#2d with variables test
test2=padding_test(DigitData, contingency_table, data_columns, max_length, num_digits, N, omit_05, break_out="DIST")$diff_in_mean[1:3, ]
s+geom_hline(yintercept=mean(as.matrix(test)), color='red')
#data style can be only 'row' or 'column'
#row means the rows has the data
#defaulted to row cuz this is how the tests returns data
hist_2D = function(data, data_style='row', hline=NA){
if (data_style == 'row'){
#transpose it to column style, what ggplot wants
data = data.frame(t(data))
}
plotting_data = data.frame(x=rownames(data), y=data)
colnames(plotting_data) = c('digit_places', 'p_values') #ensure col name are correct
print(plotting_data)
#2d plot
library(ggplot2)
hist2d = ggplot(data=plotting_data, aes(x=digit_places, y=p_values)) +
geom_bar(stat="identity")
#+ geom_text(aes(label=values), vjust=-0.3, size=3.5, color='blue') #for label exact value
if (!(is.na(hline))){
#add the horizontal line desired
hist2d = hist2d + geom_hline(yintercept=hline, color='red')
}
return(hist2d)
}
s=hist_2D(test, hline=NA)
s
s=hist_2D(test, hline=mean(as.matrix(test)))
s
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#test plot
data_columns = c("ALEXP")#,"BENTOT", "BENM", "BENF")
max_length = 7
num_digits = 5
N = 10
omit_05 = c(0,5)
test=padding_test(DigitData, contingency_table, data_columns, max_length, num_digits, N, omit_05, break_out=NA)$diff_in_mean
s=hist_2D(test, hline=mean(as.matrix(test)))
s
#2d with variables test
test2=padding_test(DigitData, contingency_table, data_columns, max_length, num_digits, N, omit_05, break_out="DIST")$diff_in_mean[1:3, ]
a=hist_2D_variables(test2)
a
#test multiple plots
plots = list(a, a, a, a)
plot_multiple_hist2d(plots)
