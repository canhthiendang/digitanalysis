#' @param plot TRUE or FALSE: If TRUE, skip last digit place before analysis. Default to TRUE.
#' @param skip_last_digit TRUE or FALSE: If TRUE, skip last digit place before analysis, since we don't want tests to overlap. Default to FALSE.
#' \code{skip_last_digit} should overwrite \code{digit_places} and \code{skip_first_digits}.
#' @param standard_df TRUE or FALSE: Default to FALSE.
#'\itemize{
#'   \item TRUE: Computes degrees of freedom for chi square test using formula df = (r-1)(c-1). If table has only one column, df = r - 1.
#'   \item FALSE: Computes degrees of freedom for chi square test using df = r x (c-1). If first digit place is present, df = r x (c-1) - 1.
#' }
#' @param suppress_low_N TRUE or FALSE: If TRUE, suppress columns in expected table
#' if at least one cell in that column has expected value < 5. Default to TRUE.
#'
#' @return
#' \itemize{
#'   \item A table of p-values for all digit tests on each category
#'   \item Plots for each category if \code{plot = TRUE}
#' }
#' @export
#'
#' @examples
#' all_digits_test(digitdata, contingency_table, data_columns='all', digit_places='all', skip_first_digit=TRUE)
#' all_digits_test(digitdata, contingency_table, data_columns='c(col_name1, col_name2)', digit_places=c(1,2,3,5), omit_05=NA, skip_last_digit=TRUE)
#' all_digits_test(digitdata, contingency_table, data_columns='all', digit_places=-1, omit_05=0, break_out='col_name', distribution='Uniform')
single_all_digits_test = function(digitdata, contingency_table, data_columns, digit_places, skip_first_digit, omit_05, category,
category_grouping, distribution, skip_last_digit, standard_df, suppress_low_N){
#######################################################################
#parse the data
#######################################################################
align_direction = 'left'
#get the digits of the desired data columns to be analyzed
lst = grab_desired_aligned_columns(digitdata, data_columns, skip_first_digit, skip_last_digit, align_direction)
digitdata = lst$digitdata
digits_table = lst$digits_table
#turn 'all' to an array of numbers if digit_places is 'all'
if (digit_places[1] == 'all'){
digit_places = seq(1, digitdata@max)
if (skip_first_digit){
digit_places = seq(2, digitdata@max)
}
}
#get usable data
usable_data = parse_digit_places(digitdata, digits_table, digit_places)
#parse only needed parts of contingency table
contingency_table = parse_contigency_table(digitdata, contingency_table, digit_places, skip_first_digit, skip_last_digit, omit_05)
#get observation table from usable data
observation_table = obtain_observation(digitdata, usable_data, digit_places, skip_first_digit, skip_last_digit, omit_05)
#######################################################################
#do chi square test
#######################################################################
#all digit test
result = chi_square_gof(observation_table, contingency_table, freq=TRUE, suppress_low_N=suppress_low_N, standard=standard_df)
p_values = data.frame(All=result$p_value)
#   #plot
#   if (plot){
#     plot_all_digit_test(digitdata, result$observed_table, digit_places, title='All')
#   }
#break on category if specified #do not plot for these
if (!(is.na(category))){
#get indexes for each category
indexes_of_categories = break_by_category(digitdata@cleaned, category, category_grouping) #this is a list since unequal number of entries for each category
#break by category for all
for (category_name in names(indexes_of_categories)){
indexes_of_category = indexes_of_categories[[category_name]]
obs_in_category = NA
#single digit place: need to change the subsetted array into dataframe with colname
usable_in_category = data.frame(usable_data[indexes_of_category, ])
colnames(usable_in_category) = colnames(usable_data)
obs_in_category = obtain_observation(digitdata, usable_in_category, digit_places, skip_first_digit, skip_last_digit, omit_05)
#chi square test
result_in_category = chi_square_gof(obs_in_category, contingency_table, freq=TRUE, suppress_low_N=suppress_low_N, standard=standard_df)
p_values[category_name] = result_in_category$p_value
# #plot
# if (plot){
#   plot_all_digit_test(digitdata, result_in_category$observed_table, digit_places, title=category_name)
# }
}
}
return(p_values)
}
all_digits_test = function(digitdata, contingency_table=NA, data_columns='all', digit_places='all', skip_first_digit=FALSE,
omit_05=c(0,5), break_out=NA, break_out_grouping=NA, category=NA, category_grouping=NA,
distribution='Benford', plot=TRUE, skip_last_digit=FALSE, standard_df=FALSE, suppress_low_N=TRUE){
#check input
input_check(digitdata=digitdata, contingency_table=contingency_table, data_columns=data_columns, digit_places=digit_places,
skip_first_digit=skip_first_digit, omit_05=omit_05, break_out=break_out, break_out_grouping=break_out_grouping,
distribution=distribution, plot=plot, skip_last_digit=skip_last_digit, standard_df=standard_df,
suppress_low_N=suppress_low_N, category=category, category_grouping=category_grouping)
#deal with contingency table and distribution situation
if (TRUE %in% ((is.na(contingency_table)))){
#if contingency_table is not passed in, use distribution
if (tolower(distribution) == 'benford'){
load(file = "data/benford_table.RData")
contingency_table = benford_table
}
else if (tolower(distribution) == 'uniform'){
load(file = "data/uniform_table.RData")
contingency_table = uniform_table
}
else {
stop('contingency_table is invalid, and distribution is not one of "benford" or "uniform"!')
}
}
#perform digit test for all
result_all = single_all_digits_test(digitdata, contingency_table, data_columns, digit_places, skip_first_digit, omit_05,
category, category_grouping, distribution, skip_last_digit, standard_df, suppress_low_N)
#p values to return
p_values = data.frame(matrix(nrow = 0, ncol = ncol(result_all)))
rownames(p_values) = rownames(result_all)
p_values['All', ] = result_all
#break on break out category if specified
if (!(is.na(break_out))){
#get indexes for each category
indexes_of_categories = break_by_category(digitdata@cleaned, break_out, break_out_grouping) #this is a list since unequal number of entries for each category
#break by category for all
for (category_name in names(indexes_of_categories)){
indexes_of_category = indexes_of_categories[[category_name]]
digitdata_of_category = make_sub_digitdata(digitdata, indexes_of_category)
result_of_category = single_all_digits_test(digitdata_of_category, contingency_table, data_columns, digit_places, skip_first_digit, omit_05,
category, category_grouping, distribution, skip_last_digit, standard_df, suppress_low_N)
p_values[category_name, ] = result_of_category
}
}
return(p_values)
}
#match the data with Jetson's
result = all_digits_test(digitdata = DigitData, contingency_table = NA, data_columns = data_columns, digit_places = digit_places,
skip_first_digit = skip_first_digit, omit_05 = omit_05, break_out=break_out, break_out_grouping=break_out_grouping,
category=category, category_grouping=category_grouping, distribution=distribution, plot=T,
skip_last_digit = skip_last_digit, standard_df=standard_df, suppress_low_N=suppress_low_N)
############################################################
#Functions for digit analysis R package
###all digits test main function in this file
#Wenjun Chang
#Summer 2020
############################################################
#' Performs all-digit-place two-way chi square test vs Benfordâ€™s Law
#'
#' @param digitdata A object of class \code{DigitAnalysis}.
#' @param contingency_table The user-input probability table of arbitrary distribution. Overwrites \code{distribution} if not NA.
#' Must be a dataframe of the form as \code{benford_table}. Defaulted to NA.
#' \itemize{
#'   \item Check out \code{load(file = "data/benford_table.RData")} to see the format of \code{benford_table}
#' }
#' @param data_columns The names of numeric columns of data to be analyzed. Default can be 'all', where using all data columns in \code{numbers} df in \code{digitdata};
#' an array of column names, as characters; a single column name, as character.
#' @param digit_places The indexes of left-aligned digit places to analyze. There are three options:
#' \itemize{
#'   \item 'all': analzye all digits. Set as default.
#'   \item An numeric array: Perform multiple digit test on the digit places desired to analyze.
#'   \item A number: Perform single digit test on the digit place desired to analyze. If last digit test is desired, pass in -1 or c(-1).
#' }
#' @param skip_first_digit TRUE or FALSE: If TRUE, skip last digit place before analysis. Default to FALSE.
#' @param omit_05 Whether to omit 0 or both 0 and 5. If omit both 0 and 5, pass in c(0,5) or c(5,0); if omit only 0 pass in 0 or c(0); if omit neither, pass in NA. Default to c(0,5).
#' @param break_out
#' \itemize{
#'   \item The data column (non-numeric!) to split up the dataset based on different categories in the column if specified as an character.
#'   \item The first division (usually x-axis) shown in plots.
#'   \item Default to NA.
#' }
#' @param break_out_grouping A list of arrays, or defaulted to NA. Only effective if \code{break_out} is not NA.
#' \itemize{
#'   \item Each the names of the elements in the list is the break_out name
#'   \item Each array contains the values belonging to that break_out
#'   \item If it is remain as NA as default, while \code{break_out} is not NA, then \code{break_out_grouping} will default to every individual item in
#'   \code{break_out} will be in a separate group.
#' }
#' @param distribution 'Benford' or 'Uniform'. Case insensitive. Specifies the distribution the chi square test is testing against. Default to 'Benford'.
#' @param plot TRUE or FALSE: If TRUE, skip last digit place before analysis. Default to TRUE.
#' @param skip_last_digit TRUE or FALSE: If TRUE, skip last digit place before analysis, since we don't want tests to overlap. Default to FALSE.
#' \code{skip_last_digit} should overwrite \code{digit_places} and \code{skip_first_digits}.
#' @param standard_df TRUE or FALSE: Default to FALSE.
#'\itemize{
#'   \item TRUE: Computes degrees of freedom for chi square test using formula df = (r-1)(c-1). If table has only one column, df = r - 1.
#'   \item FALSE: Computes degrees of freedom for chi square test using df = r x (c-1). If first digit place is present, df = r x (c-1) - 1.
#' }
#' @param suppress_low_N TRUE or FALSE: If TRUE, suppress columns in expected table
#' if at least one cell in that column has expected value < 5. Default to TRUE.
#'
#' @return
#' \itemize{
#'   \item A table of p-values for all digit tests on each category
#'   \item Plots for each category if \code{plot = TRUE}
#' }
#' @export
#'
#' @examples
#' all_digits_test(digitdata, contingency_table, data_columns='all', digit_places='all', skip_first_digit=TRUE)
#' all_digits_test(digitdata, contingency_table, data_columns='c(col_name1, col_name2)', digit_places=c(1,2,3,5), omit_05=NA, skip_last_digit=TRUE)
#' all_digits_test(digitdata, contingency_table, data_columns='all', digit_places=-1, omit_05=0, break_out='col_name', distribution='Uniform')
single_all_digits_test = function(digitdata, contingency_table, data_columns, digit_places, skip_first_digit, omit_05, category,
category_grouping, distribution, skip_last_digit, standard_df, suppress_low_N){
#######################################################################
#parse the data
#######################################################################
align_direction = 'left'
#get the digits of the desired data columns to be analyzed
lst = grab_desired_aligned_columns(digitdata, data_columns, skip_first_digit, skip_last_digit, align_direction)
digitdata = lst$digitdata
digits_table = lst$digits_table
#turn 'all' to an array of numbers if digit_places is 'all'
if (digit_places[1] == 'all'){
digit_places = seq(1, digitdata@max)
if (skip_first_digit){
digit_places = seq(2, digitdata@max)
}
}
#get usable data
usable_data = parse_digit_places(digitdata, digits_table, digit_places)
#parse only needed parts of contingency table
contingency_table = parse_contigency_table(digitdata, contingency_table, digit_places, skip_first_digit, skip_last_digit, omit_05)
#get observation table from usable data
observation_table = obtain_observation(digitdata, usable_data, digit_places, skip_first_digit, skip_last_digit, omit_05)
#######################################################################
#do chi square test
#######################################################################
#all digit test
result = chi_square_gof(observation_table, contingency_table, freq=TRUE, suppress_low_N=suppress_low_N, standard=standard_df)
p_values = data.frame(All=result$p_value)
#   #plot
#   if (plot){
#     plot_all_digit_test(digitdata, result$observed_table, digit_places, title='All')
#   }
#break on category if specified #do not plot for these
if (!(is.na(category))){
#get indexes for each category
indexes_of_categories = break_by_category(digitdata@cleaned, category, category_grouping) #this is a list since unequal number of entries for each category
#break by category for all
for (category_name in names(indexes_of_categories)){
indexes_of_category = indexes_of_categories[[category_name]]
obs_in_category = NA
#single digit place: need to change the subsetted array into dataframe with colname
usable_in_category = data.frame(usable_data[indexes_of_category, ])
colnames(usable_in_category) = colnames(usable_data)
obs_in_category = obtain_observation(digitdata, usable_in_category, digit_places, skip_first_digit, skip_last_digit, omit_05)
#chi square test
result_in_category = chi_square_gof(obs_in_category, contingency_table, freq=TRUE, suppress_low_N=suppress_low_N, standard=standard_df)
p_values[category_name] = result_in_category$p_value
# #plot
# if (plot){
#   plot_all_digit_test(digitdata, result_in_category$observed_table, digit_places, title=category_name)
# }
}
}
return(p_values)
}
all_digits_test = function(digitdata, contingency_table=NA, data_columns='all', digit_places='all', skip_first_digit=FALSE,
omit_05=c(0,5), break_out=NA, break_out_grouping=NA, category=NA, category_grouping=NA,
distribution='Benford', plot=TRUE, skip_last_digit=FALSE, standard_df=FALSE, suppress_low_N=TRUE){
#check input
input_check(digitdata=digitdata, contingency_table=contingency_table, data_columns=data_columns, digit_places=digit_places,
skip_first_digit=skip_first_digit, omit_05=omit_05, break_out=break_out, break_out_grouping=break_out_grouping,
distribution=distribution, plot=plot, skip_last_digit=skip_last_digit, standard_df=standard_df,
suppress_low_N=suppress_low_N, category=category, category_grouping=category_grouping)
#deal with contingency table and distribution situation
if (TRUE %in% ((is.na(contingency_table)))){
#if contingency_table is not passed in, use distribution
if (tolower(distribution) == 'benford'){
load(file = "data/benford_table.RData")
contingency_table = benford_table
}
else if (tolower(distribution) == 'uniform'){
load(file = "data/uniform_table.RData")
contingency_table = uniform_table
}
else {
stop('contingency_table is invalid, and distribution is not one of "benford" or "uniform"!')
}
}
#perform digit test for all
result_all = single_all_digits_test(digitdata, contingency_table, data_columns, digit_places, skip_first_digit, omit_05,
category, category_grouping, distribution, skip_last_digit, standard_df, suppress_low_N)
#p values to return
p_values = data.frame(matrix(nrow = 0, ncol = ncol(result_all)))
colnames(p_values) = colnames(result_all)
p_values['All', ] = result_all
#break on break out category if specified
if (!(is.na(break_out))){
#get indexes for each category
indexes_of_categories = break_by_category(digitdata@cleaned, break_out, break_out_grouping) #this is a list since unequal number of entries for each category
#break by category for all
for (category_name in names(indexes_of_categories)){
indexes_of_category = indexes_of_categories[[category_name]]
digitdata_of_category = make_sub_digitdata(digitdata, indexes_of_category)
result_of_category = single_all_digits_test(digitdata_of_category, contingency_table, data_columns, digit_places, skip_first_digit, omit_05,
category, category_grouping, distribution, skip_last_digit, standard_df, suppress_low_N)
p_values[category_name, ] = result_of_category
}
}
return(p_values)
}
#match the data with Jetson's
result = all_digits_test(digitdata = DigitData, contingency_table = NA, data_columns = data_columns, digit_places = digit_places,
skip_first_digit = skip_first_digit, omit_05 = omit_05, break_out=break_out, break_out_grouping=break_out_grouping,
category=category, category_grouping=category_grouping, distribution=distribution, plot=T,
skip_last_digit = skip_last_digit, standard_df=standard_df, suppress_low_N=suppress_low_N)
result
############################################################
#Testing for unpack unround column tests
#Wenjun Chang
#Summer 2020
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
##############################
#general functions
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function.R')
############################
#testing
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load chi square test GOF functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\chi_square_goodness_of_fit_functions.R')
#load main function for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_main_function.R')
#test with data
#load data input functions
data_columns = c("ALEXP.Values")#c("BENM", "BENF")#
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
#DigitData has to drop all columns with NA in ALEXP.Values
indexes_with_valid_alexp_values = which(!(is.na(DigitData@cleaned$ALEXP.Values)))
DigitData = make_sub_digitdata(DigitData, indexes_with_valid_alexp_values)
#test all digits test
data_columns = 'all'#'ALEXP.Values'#
digit_places =  'all'
skip_first_digit=TRUE
omit_05 = c(0,5)
break_out='DIST'
break_out_grouping=NA
category='YEAR'
category_grouping=NA
skip_last_digit=FALSE
standard_df=TRUE
suppress_low_N=FALSE
distribution = 'benford'
#match the data with Jetson's
result = all_digits_test(digitdata = DigitData, contingency_table = NA, data_columns = data_columns, digit_places = digit_places,
skip_first_digit = skip_first_digit, omit_05 = omit_05, break_out=break_out, break_out_grouping=break_out_grouping,
category=category, category_grouping=category_grouping, distribution=distribution, plot=T,
skip_last_digit = skip_last_digit, standard_df=standard_df, suppress_low_N=suppress_low_N)
result
# order = c('Mandera', 'Isiolo', 'Baringo', 'Ijara', 'Wajir', 'Garissa', 'Samburu', 'Marsabit', 'Moyale', 'Turkana', 'Tana', 'all')
# result[order]
############################################################
#Testing for padding test
#Wenjun Chang
#Summer 2020
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
##############################
#general functions
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function.R')
############################
#testing
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load all functions for padding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\padding_test.R')
#test with data
#load data input functions
data_columns = c("ALEXP.Values")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
#DigitData has to drop all columns with NA in ALEXP.Values
indexes_with_valid_alexp_values = which(!(is.na(DigitData@cleaned$ALEXP.Values)))
DigitData = make_sub_digitdata(DigitData, indexes_with_valid_alexp_values)
#test padding test
data_columns = c("ALEXP.Values")#c("ALEXP")#,"BENTOT", "BENM", "BENF")
max_length = 7
num_digits = 5
N = 100 #120k datasets took 15 mins #2400s for N=10,000; data = 4000 x 5, all data
omit_05 = c(0,5)
break_out = NA#'DIST'
break_out_grouping=NA
category= NA#'SECTOR'
category_grouping = NA#list(Training_and_Transport=c("TRN", "TRAVEL", "VEHICLES"), Civil_Works=c("CW"), Goods_and_Equipment=c("GE"))
distribution='benford'
ptm <- proc.time()
#match the data with Jetson's
result = padding_test(digitdata=DigitData, contingency_table=NA, data_columns=data_columns, max_length=max_length,
num_digits=num_digits, N=N, omit_05=omit_05, distribution=distribution, break_out=break_out,
break_out_grouping=break_out_grouping, category=category, category_grouping=category_grouping, plot=TRUE)
result
proc.time() - ptm
'############################################################
#Testing for padding test
#Wenjun Chang
#Summer 2020
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
##############################
#general functions
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function.R')
############################
#testing
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load all functions for padding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\padding_test.R')
#test with data
#load data input functions
data_columns = c("ALEXP.Values")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
#DigitData has to drop all columns with NA in ALEXP.Values
indexes_with_valid_alexp_values = which(!(is.na(DigitData@cleaned$ALEXP.Values)))
DigitData = make_sub_digitdata(DigitData, indexes_with_valid_alexp_values)
#test padding test
data_columns = c("ALEXP.Values")#c("ALEXP")#,"BENTOT", "BENM", "BENF")
max_length = 7
num_digits = 5
N = 100000 #120k datasets took 15 mins #2400s for N=10,000; data = 4000 x 5, all data
omit_05 = c(0,5)
break_out = NA#'DIST'
break_out_grouping=NA
category= NA#'SECTOR'
category_grouping = NA#list(Training_and_Transport=c("TRN", "TRAVEL", "VEHICLES"), Civil_Works=c("CW"), Goods_and_Equipment=c("GE"))
distribution='benford'
ptm <- proc.time()
#match the data with Jetson's
result = padding_test(digitdata=DigitData, contingency_table=NA, data_columns=data_columns, max_length=max_length,
num_digits=num_digits, N=N, omit_05=omit_05, distribution=distribution, break_out=break_out,
break_out_grouping=break_out_grouping, category=category, category_grouping=category_grouping, plot=TRUE)
result
proc.time() - ptm
############################################################
#Testing for padding test
#Wenjun Chang
#Summer 2020
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
##############################
#general functions
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function.R')
############################
#testing
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load all functions for padding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\padding_test.R')
#test with data
#load data input functions
data_columns = c("ALEXP.Values")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
#DigitData has to drop all columns with NA in ALEXP.Values
indexes_with_valid_alexp_values = which(!(is.na(DigitData@cleaned$ALEXP.Values)))
DigitData = make_sub_digitdata(DigitData, indexes_with_valid_alexp_values)
#test padding test
data_columns = c("ALEXP.Values")#c("ALEXP")#,"BENTOT", "BENM", "BENF")
max_length = 7
num_digits = 5
N = 100000 #120k datasets took 15 mins #2400s for N=10,000; data = 4000 x 5, all data
omit_05 = c(0,5)
break_out = NA#'DIST'
break_out_grouping=NA
category= NA#'SECTOR'
category_grouping = NA#list(Training_and_Transport=c("TRN", "TRAVEL", "VEHICLES"), Civil_Works=c("CW"), Goods_and_Equipment=c("GE"))
distribution='benford'
ptm <- proc.time()
#match the data with Jetson's
result = padding_test(digitdata=DigitData, contingency_table=NA, data_columns=data_columns, max_length=max_length,
num_digits=num_digits, N=N, omit_05=omit_05, distribution=distribution, break_out=break_out,
break_out_grouping=break_out_grouping, category=category, category_grouping=category_grouping, plot=TRUE)
result
proc.time() - ptm
