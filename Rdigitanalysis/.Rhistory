data[data == 0] = NA
if (length(omit_05) == 2){
#remove 5 entries
data[data == 5] = NA
}
}
observed_mean = data.frame(t(colMeans(data, na.rm = TRUE))) #do t() such that it is a dataframe
colnames(observed_mean) = colnames(data)#change col names cuz it is weird due to data.frame()
return(observed_mean)
}
#' Stimulatse N Benford distribution datasets with matching digit places as the observed dataset. SHOULD I EXPORT THIS???!!!
#'
#' @param freq_table \code{freq_table} item returned from \code{get_expected_mean}
#' @param expected_mean \code{expected_mean} item returned from \code{get_expected_mean}
#' @inheritParams padding_test
#'
#' @return A dataframe for the mean of each stimulated dataset in every digit place
#' @export
Benford_stimulation = function(N, freq_table, expected_mean, contingency_table){
#sample each digit place from right according to frequency table of our observed dataset
#initialize the returned table
stimulated_mean = data.frame(matrix(nrow = 0, ncol = length(expected_mean)))
colnames(stimulated_mean) = colnames(expected_mean)
#stimulate n datasets
for (n in 1:N){
#initialize the row for this stimulated set
stimulated_mean[paste('sample', as.character(n)), ] = NA
for (i in 1:length(freq_table)){
#the frequency of each left-aligned digits in each right-aligned digit
freq_of_digit_position = freq_table[[i]]
#stimulate data
stimulated_numbers = c()
for (j in 1:length(freq_of_digit_position)){
#returns logical(0) if sample 0 number
size = freq_of_digit_position[j]
if (size != 0){
#sample according to the digit place probability and with the size
stimulated_numbers = c(stimulated_numbers, sample(contingency_table[['Digits']], size = size, replace = TRUE, prob = contingency_table[[paste('Digit Place', as.character(j))]]))
}
}
stimulated_mean[paste('sample', as.character(n)), ][i] = mean(stimulated_numbers)
}
}
return(stimulated_mean)
}
#' Obtains p_values for comparing with Monte Carlo stimulated datasets
#'
#' @param observed_mean \code{observed_mean} returned from \code{get_observed_mean}
#' @param stimulated_mean \code{stimulated_mean} returned from \code{Benford_stimulation}
#'
#' @return A table of p-values for each digit place
get_p_value = function(observed_mean, stimulated_mean){
p_values = data.frame(matrix(nrow=1, ncol=length(observed_mean)))
colnames(p_values) = colnames(observed_mean)
combined_mean_data = rbind(observed_mean, stimulated_mean)
for (i in 1:length(observed_mean)){
#combine observed and stimulated and find rank of observed
#first row is observation --> first index
p_values[i] = rank(-combined_mean_data[[i]])[1] / length(combined_mean_data[,i])
}
return(p_values)
}
####
#need ADD plot parameter
####
#' Performs padding test vs stimulations of Benford conforming datasets via percentile
#'
#' @param max_length The length of the longest numbers considered. Defaulted to 8.
#' @param num_digits The total number of digits aligned from the right to be analyzed. Defaulted to 5, meaning analyzing digit place 1s to 10ks.
#' @param N The number of Benford conforming datasets to stimulate.
#' @inheritParams all_digits_test
#'
#' @return
#' \itemize{
#'   \item A list with 4 elements
#'   \itemize{
#'     \item \code{expected_mean}: the expected mean by Benford's Law
#'     \item \code{observed_mean}: the mean of the input data
#'     \item \code{diff_in_mean}: the mean difference betweeen observed_mean and expected_mean
#'     \item \code{p_values}: the percentile of the observed dataset among all stimulated datasets in decreasing order
#'   }
#'   \item Plots on \code{diff_in_mean} for each category if \code{plot = TRUE}
#' }
#' @export
#'
#' @examples
#' padding_test(digitdata, contingency_table, data_columns='all')
#' padding_test(digitdata, contingency_table, data_columns=c('col_name1', 'col_name2'), omit_05=NA)
#' padding_test(digitdata, contingency_table, data_columns='all', max_length=7, num_digits=3, omit_05=0)
#' padding_test(digitdata, contingency_table, data_columns='all', N=100, omit_05=NA, break_out='col_name')
padding_test = function(digitdata, contingency_table, data_columns='all', max_length=8, num_digits=5, N=10000, omit_05=c(0,5), break_out=NA, plot=TRUE){
#check input
input_check(digitdata=digitdata, contingency_table=contingency_table, data_columns=data_columns, omit_05=omit_05,
break_out=break_out, max_length=max_length, num_digits=num_digits, N=N)
#get benford mean in each digit place
Benford = get_benford_mean(contingency_table, omit_05)
Benford_mean = Benford$Benford_mean
contingency_table = Benford$contingency_table
######################################################
#handle the data_columns = 'all' situation
data_columns = get_data_columns(digitdata, data_columns)
#get combined by rows data for all data columns needed
combined_data = combine_by_columns(digitdata, data_columns, indexes=NA)
#get expected and observed mean in each digit position
lst = get_expected_mean(digitdata, combined_data, Benford_mean, max_length, num_digits)
freq_table=lst$freq_table
expected_mean = lst$expected_mean
rownames(expected_mean) = 'All'
observed_mean = get_observed_mean(lst$final_data, num_digits)
rownames(observed_mean) = 'All'
#get the difference in expected and observed mean in each digit position
diff_in_mean = observed_mean - expected_mean
rownames(diff_in_mean) = 'All'
#Monte Carlo Stimulation of N datasets and get mean
stimulated_mean = Benford_stimulation(N, freq_table, expected_mean, contingency_table)
#get p values by comparing with stimulation
p_values = get_p_value(observed_mean, stimulated_mean)
rownames(p_values) = 'All'
######################################################
#break out by category
if (!(is.na(break_out))){
#get indexes for each category
indexes_of_categories = break_by_category(digitdata@cleaned, break_out) #this is a list since unequal number of entries for each category
#break by category for all
for (category_name in names(indexes_of_categories)){
indexes_of_category = indexes_of_categories[[category_name]]
######################################################
#get combined by rows data for all data columns needed
combined_data_of_category = combine_by_columns(digitdata, data_columns, indexes=indexes_of_category)
#get expected and observed mean in each digit position
lst = get_expected_mean(digitdata, combined_data_of_category, Benford_mean, max_length, num_digits)
freq_table=lst$freq_table
expected_mean[category_name, ] = lst$expected_mean
observed_mean[category_name, ] = get_observed_mean(lst$final_data, num_digits)
#get the difference in expected and observed mean in each digit position
diff_in_mean[category_name, ]  = observed_mean[category_name, ] - expected_mean[category_name, ]
#Monte Carlo Stimulation of N datasets and get mean
stimulated_mean = Benford_stimulation(N, freq_table, expected_mean[category_name, ], contingency_table)
#get p values by comparing with stimulation
p_values[category_name, ] = get_p_value(observed_mean[category_name, ], stimulated_mean)
######################################################
}
}
if (plot){
#2D histogram
if (is.na(break_out)){
print(hist_2D(diff_in_mean, data_style='row', xlab='Digit Place', ylab='Deviation from Mean', title='Padding Test: Deviation from Mean', hline=NA, hline_name=''))
}
#Multi-variable 2D histogram
else {
print(hist_2D_variables(diff_in_mean, data_style='row', xlab='Digit Place', ylab='Deviation from Mean', title='Padding Test: Deviation from Mean'))
}
}
return(list(diff_in_mean=diff_in_mean, p_values=p_values, expected_mean=expected_mean, observed_mean=observed_mean))
}
############################################################
#Testing for padding test
#Wenjun Chang
#Summer 2020
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
##############################
#general functions
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function.R')
############################
#testing
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load all functions for padding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\padding_test.R')
#test with data
#load data input functions
data_columns = c("ALEXP.Values")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
#test padding test
data_columns = c("ALEXP.Values")#c("ALEXP")#,"BENTOT", "BENM", "BENF")
max_length = 7
num_digits = 5
N = 10 #120k datasets took 15 mins
omit_05 = c(0,5)
break_out = 'DIST'
#match the data with Jetson's
result = padding_test(digitdata=DigitData, contingency_table=contingency_table, data_columns=data_columns, max_length=max_length,
num_digits=num_digits, N=N, omit_05=omit_05, break_out=break_out, plot=TRUE)
result
############################################################
#Testing for padding test
#Wenjun Chang
#Summer 2020
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
##############################
#general functions
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function.R')
############################
#testing
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load all functions for padding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\padding_test.R')
#test with data
#load data input functions
data_columns = c("ALEXP.Values")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
#test padding test
data_columns = c("ALEXP.Values")#c("ALEXP")#,"BENTOT", "BENM", "BENF")
max_length = 7
num_digits = 5
N = 100000 #120k datasets took 15 mins
omit_05 = c(0,5)
break_out = NA#'DIST'
#match the data with Jetson's
result = padding_test(digitdata=DigitData, contingency_table=contingency_table, data_columns=data_columns, max_length=max_length,
num_digits=num_digits, N=N, omit_05=omit_05, break_out=break_out, plot=TRUE)
result
hist2D(result$diff_in_mean)
hist_2D(result$diff_in_mean)
result$diff_in_mean
############################################################
#Testing for padding test
#Wenjun Chang
#Summer 2020
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
##############################
#general functions
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function.R')
############################
#testing
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load all functions for padding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\padding_test.R')
#test with data
#load data input functions
data_columns = c("ALEXP.Values")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
#test padding test
data_columns = c("ALEXP.Values")#c("ALEXP")#,"BENTOT", "BENM", "BENF")
max_length = 7
num_digits = 5
N = 10 #120k datasets took 15 mins
omit_05 = c(0,5)
break_out = 'DIST'
#match the data with Jetson's
result = padding_test(digitdata=DigitData, contingency_table=contingency_table, data_columns=data_columns, max_length=max_length,
num_digits=num_digits, N=N, omit_05=omit_05, break_out=break_out, plot=TRUE)
result
############################################################
#Functions for digit analysis R package
###plotting helper functions
#Wenjun Chang
#Summer 2020
############################################################
#' Stackoverflow method to specify number of ticks for \code{ggplot::scale_y_continuous()}
#'
#' @param n Number of ticks desired
#'
#' @return Nothing is returned.
number_ticks <- function(n) {function(limits) pretty(limits, n)}
#' Plot 2d histogram given data. Either rownames or colnames will be x values, and the data will be y values.
#'
#' @param data The 1D dataframe to be plotted.
#' @param data_style The style of input \code{data}. \code{ggplot} requires columns to be the arrays for x values, y values, etc.
#' \itemize{
#'   \item If \code{data} has a row for y values, pass in 'row'.
#'   \item If \code{data} has a column for y values, pass in 'col'.
#'   \item Defaulted to 'row'.
#' }
#'
#' @param xlab x-axis label. Defaulted to 'digits'.
#' @param ylab y-axis label. Defaulted to 'frequency'.
#' @param title Plot title. Defaulted to '2D Histogram'.
#' @param hline Specifies the y-intercept value if a horizontal line is desired. Defaulted to NA.
#'
#' @return A ggplot instance.
hist_2D = function(data, data_style='row', xlab='digits', ylab='frequency', title='2D Histogram', hline=NA, hline_name=''){
if (data_style == 'row'){
#transpose it to column style, what ggplot wants
data = data.frame(t(data))
}
plotting_data = data.frame(x=rownames(data), y=data)
colnames(plotting_data) = c('x', 'y') #ensure col name are correct
#2d plot
library(ggplot2)
hist2d = ggplot(data=plotting_data, aes(x=x, y=y)) +
geom_bar(stat="identity") + xlab(xlab) + ylab(ylab) + ggtitle(title) + scale_x_discrete(limits=rownames(data)) +
scale_y_continuous(breaks=number_ticks(10)) + theme(legend.position="top")
#+ geom_text(aes(label=values), vjust=-0.3, size=3.5, color='blue') #for label exact value
#add the horizontal line desired
if (!(is.na(hline))){
hist2d = hist2d + geom_hline(aes(yintercept=hline, linetype=hline_name), color='red', lwd=1)
}
return(hist2d)
}
#' Plot 2d histogram with multiple varibales as specified by typically the \code{break_out} in digit tests.
#' If \code{data} is row style, rownames would be the categories, and colnames would be x values.
#'
#' @param data The 2D dataframe to be plotted.
#' @inheritParams hist_2D
#'
#' @return A ggplot instance.
hist_2D_variables = function(data, data_style='row', xlab='digits', ylab='frequency', title='Multi-variable 2D Histogram'){
if (data_style == 'row'){
#transpose it to column style, what ggplot wants
data = data.frame(t(data))
}
#intialize a df for plotting, columns = x, y, category
plotting_data = data.frame(matrix(nrow = 0, ncol = 3))
colnames(plotting_data) = c('x', 'y', 'category')
#fill up df
for (name in colnames(data)){
single_category_data = data.frame(x=rownames(data), y=data[[name]], category=rep(name, nrow(data)))
plotting_data = rbind(plotting_data, single_category_data)
}
#stacked 2d barplot with multiple groups
#use position=position_dodge()
library(ggplot2)
hist2d_multiple = ggplot(data=plotting_data, aes(x=x, y=y, fill=category)) +
geom_bar(stat="identity", position=position_dodge()) + scale_x_discrete(limits=rownames(data)) +
scale_fill_grey(start=0.7, end=0.3) + scale_y_continuous(breaks=number_ticks(10)) +
xlab(xlab) + ylab(ylab) + ggtitle(title) #ensure order of digit places
#+ theme(legend.position="bottom") #legend position
return(hist2d_multiple)
}
#' Plot multiple plots on a single image
#'
#' @param plot_list A list of ggplot instances
#'
#' @return A plot instance with all plots in one single figure
plot_multiple_hist2d = function(plot_list){
require(gridExtra)
plots = do.call("grid.arrange", c(plot_list, nrow = floor(sqrt(length(plot_list)))))
return(plots)
}
#' Plot 2D histogram on digits freqency on each digit place in a single figure using \code{hist_2D} and \code{plot_multiple_hist2d}
#'
#' @param digits_table The digits table for counts in each digits in each digit place
#' @inheritParams hist_2D
#'
#' @return A figure with each data column's value plotted against rownames
plot_table_by_columns = function(digits_table, name='', data_style='col', save=FALSE){
plot_list = list()
for (i in 1:length(digits_table)){
curr_digit_place = colnames(digits_table)[i]
hist_digit_place_i = hist_2D(digits_table[i], data_style=data_style, xlab='digits', ylab='frequency', title=paste(name, curr_digit_place), hline=NA)
plot_list[[curr_digit_place]] = hist_digit_place_i
}
plots = plot_multiple_hist2d(plot_list)
# if (save){
#   filename = paste(name, '_2D_histograms.pdf', sep='')
#   print(filename)
#   ggsave(plots, file=paste(name, '_2D_histograms.pdf', sep=''))
# }
return(plots)
}
#' Plot 3D histogram. The display follows that rows will be x-axis, and columns will be y-axis.
#'
#' @param data The 2D dataframe to be plotted.
#' @param zlab z-axis label. Defaulted to 'frequency'.
#' @param theta x-y (left-right) viewing angle. Defaulted to 55.
#' @param phi xy-z (up-down) viewing angle. Defaulted to 16.
#' @inheritParams hist_2D
#' @inheritParams all_digits_test
#'
#' @return Nothing is returned. Displays a \code{plot3D} 3d plot automatically.
hist_3d = function(data, digitdata, xlab='digits', ylab='digit places', zlab='frequency', title='3D Bar Plot', theta=55, phi=16, save=FALSE){
#assert digitdata is of correct class
input_check(digitdata=digitdata)
x = as.numeric(rownames(data))
y = as.numeric(which(digitdata@left_aligned_column_names %in% colnames(data)))
z = as.matrix(data)
plot3D::hist3D(x=x, y=y, z=z, zlim=c(0,max(z, na.rm=TRUE)+0.01), bty = "b2", theta=theta, phi=phi, axes=TRUE, label=TRUE, nticks=max(length(x),length(y)),
ticktype="detailed", space=0, expand=0.5, d=2, col='grey', colvar=NA, border='black', shade=0,
lighting=list('ambient'=0.6, 'diffuse'=0.6), main=title, xlab=xlab, ylab=ylab, zlab=zlab)
# if (save){
#   filename = paste(title, ".pdf", sep='')
#   print(filename)
#   pdf(file = filename)
#   plot3D::hist3D(x=x, y=y, z=z, zlim=c(0,max(z, na.rm=TRUE)+0.01), bty = "b2", theta=theta, phi=phi, axes=TRUE, label=TRUE, nticks=max(length(x),length(y)),
#                  ticktype="detailed", space=0, expand=0.5, d=2, col='grey', colvar=NA, border='black', shade=0,
#                  lighting=list('ambient'=0.6, 'diffuse'=0.6), main=title, xlab=xlab, ylab=ylab, zlab=zlab)#, cex.axis = 1e-9)
#   # plot3D::text3D(x = 1:length(x)+0.3, y = rep(1.15, length(x)), z = rep(0, length(x)), labels = x, add = TRUE, adj = 0)
#   # plot3D::text3D(x = rep(0, length(y)), y = 1:length(y)+0.5, z = rep(1, length(y)), labels = y, add = TRUE, adj = 1)
#   dev.off()
# }
return()
}
#' Plots the relevant plots for obseravtion table in \code{all_digits_test}.
#'
#' @param observation_table Observation table for chi square test
#' @param title The title for the plot after automatically generating the name for the test: either single digit test or all digit test.
#' @inheritParams all_digits_test
#'
#' @return Nothing is returned. Displays plots automatically.
plot_all_digit_test = function(digitdata, observation_table, digit_places, title=''){
test_type = NA
#turn observation table from counts into frequency
for (i in 1:length(observation_table)){
observation_table[, i] = observation_table[, i] / sum(observation_table[, i], na.rm = TRUE)
}
if (length(digit_places) == 1){
test_type = 'Single Digit Test'
plot_table_by_columns(observation_table, name=paste(title, test_type, sep='_'), data_style='col') #multiple 2D histograms
}
else if (!(FALSE %in% (dim(digitdata@raw) == c(0,0)))){
test_type = 'Unpack Rounded Numbers Test'
#round numbers
if (digitdata@numbers[[1]][1] %% 10 == 0){
hist_3d(observation_table, digitdata, xlab='digits', ylab='digit places', zlab='frequency', title=paste(title, '(Round Numbers)', test_type, sep='_')) #3D histogram
#plot_table_by_columns(observation_table, name=paste(title, '(Round Numbers)', test_type, sep='_'), data_style='col') #multiple 2D histograms
}
else {
hist_3d(observation_table, digitdata, xlab='digits', ylab='digit places', zlab='frequency', title=paste(title, '(Unround Numbers)', test_type, sep='_')) #3D histogram
#plot_table_by_columns(observation_table, name=paste(title, '(Unround Numbers)', test_type, sep='_'), data_style='col') #multiple 2D histograms
}
}
else {
test_type = 'All Digit Test'
hist_3d(observation_table, digitdata, xlab='digits', ylab='digit places', zlab='frequency', title=paste(title, test_type, sep='_')) #3D histogram
plot_table_by_columns(observation_table, name=paste(title, test_type, sep='_'), data_style='col') #multiple 2D histograms
}
return()
}
#
# result = all_digits_test(digitdata = DigitData, contingency_table = contingency_table, data_columns = data_columns, digit_places = digit_places,
#                          skip_first_digit = skip_first_digit, omit_05 = omit_05, break_out=NA, distribution='Benford', plot=TRUE, skip_last_digit = skip_last_digit, standard_df=TRUE)
#
# library("plot3Drgl")
# plotrgl()
############################################################
#Testing for padding test
#Wenjun Chang
#Summer 2020
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
##############################
#general functions
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function.R')
############################
#testing
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load all functions for padding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\padding_test.R')
#test with data
#load data input functions
data_columns = c("ALEXP.Values")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
#test padding test
data_columns = c("ALEXP.Values")#c("ALEXP")#,"BENTOT", "BENM", "BENF")
max_length = 7
num_digits = 5
N = 10 #120k datasets took 15 mins
omit_05 = c(0,5)
break_out = NA#'DIST'
#match the data with Jetson's
result = padding_test(digitdata=DigitData, contingency_table=contingency_table, data_columns=data_columns, max_length=max_length,
num_digits=num_digits, N=N, omit_05=omit_05, break_out=break_out, plot=TRUE)
result
