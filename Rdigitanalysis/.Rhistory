print('sfsff')
#handle the data_columns = 'all' situation
data_columns = get_data_columns(digitdata, data_columns)
print('fucker')
digitdata@max = 0
for (col_name in data_columns){
single_column_digits = single_column_aligned(digitdata, col_name, align_direction)
#update the max attribute of digitdata for use in other functions
if (digitdata@max < as.numeric(length(single_column_digits))){
#print('sfdsff')
#print(head(single_column_digits))
#print(as.numeric(length(single_column_digits)))
#print(digitdata@max)
digitdata@max = as.numeric(length(single_column_digits))
#print(digitdata@max)
}
print('hey')
###!!!!!!!!!!!!!!!!!!!!!!!
#remove last digit before remove first, to avoid problems like there are 1-digit numbers
if (skip_last_digit){
single_column_digits = drop_last_digit_places(digitdata, single_column_digits, align_direction)
}
print('gugggma')
if (skip_first_figit){
single_column_digits = drop_first_digit_places(digitdata, single_column_digits, align_direction)
}
print('woooooo')
digits_table = cbind(digits_table, single_column_digits)
}
return(list('digits_table'=digits_table, 'digitdata'=digitdata))
}
grab_desired_aligned_columns(round_digitdata, data_columns, skip_first_figit, skip_last_digit)
#gets the desired data columns for analysis, can be left or right aligned
#also in the mean time drop the first and last digit places if it is desired
grab_desired_aligned_columns = function(digitdata, data_columns, skip_first_figit=TRUE, skip_last_digit=FALSE, align_direction='left'){
digits_table = data.frame(matrix(ncol = 0, nrow = length(digitdata@numbers[,1])))
print('sfsff')
#handle the data_columns = 'all' situation
data_columns = get_data_columns(digitdata, data_columns)
print('fucker')
digitdata@max = 0
for (col_name in data_columns){
single_column_digits = single_column_aligned(digitdata, col_name, align_direction)
#update the max attribute of digitdata for use in other functions
if (digitdata@max < as.numeric(length(single_column_digits))){
#print('sfdsff')
#print(head(single_column_digits))
#print(as.numeric(length(single_column_digits)))
print(digitdata@max)
digitdata@max = as.numeric(length(single_column_digits))
#print(digitdata@max)
}
print('hey')
###!!!!!!!!!!!!!!!!!!!!!!!
#remove last digit before remove first, to avoid problems like there are 1-digit numbers
if (skip_last_digit){
single_column_digits = drop_last_digit_places(digitdata, single_column_digits, align_direction)
}
print('gugggma')
if (skip_first_figit){
single_column_digits = drop_first_digit_places(digitdata, single_column_digits, align_direction)
}
print('woooooo')
print(dim(single_column_digits))
digits_table = cbind(digits_table, single_column_digits)
}
return(list('digits_table'=digits_table, 'digitdata'=digitdata))
}
grab_desired_aligned_columns(round_digitdata, data_columns, skip_first_figit, skip_last_digit)
#gives the table for the left/right aligned table for a single numeric data column ############################
#digitdata is an object of the class DigitAnalysis!                               ############################ Also user friendly, can let user use it to check their data
#desired_col should be a string!
single_column_aligned = function(digitdata, desired_col, align_diretion='left') {
if (is.na(match(desired_col, colnames(digitdata@numbers)))){
#throw error
stop("Specified desired_col is not a numerical data column in the specified DigitAnalysis class object")
} else {
#add a space at the end to avoid picking up alternative superstring column names
checking = paste(desired_col, '')
original_df = NA
if (align_diretion == 'left') {
original_df = digitdata@left_aligned
}
else if (align_diretion == 'right') {
original_df = digitdata@right_aligned
}
else {
stop("align_direction must be either 'left' or 'right'")
}
#create output table
single_align_df = data.frame(matrix(ncol = 0, nrow = length(original_df[,1])))
column_names = colnames(original_df)
for (i in 1:length(column_names)){
if (grepl(checking, column_names[i], fixed=TRUE)){
single_align_df[[column_names[i]]] = NA
single_align_df[[column_names[i]]] = original_df[[column_names[i]]]
}
}
return(single_align_df)
}
}
#gets the desired data columns for analysis, can be left or right aligned
#also in the mean time drop the first and last digit places if it is desired
grab_desired_aligned_columns = function(digitdata, data_columns, skip_first_figit=TRUE, skip_last_digit=FALSE, align_direction='left'){
digits_table = data.frame(matrix(ncol = 0, nrow = length(digitdata@numbers[,1])))
print('sfsff')
#handle the data_columns = 'all' situation
data_columns = get_data_columns(digitdata, data_columns)
print('fucker')
digitdata@max = 0
for (col_name in data_columns){
single_column_digits = single_column_aligned(digitdata, col_name, align_direction)
#update the max attribute of digitdata for use in other functions
if (digitdata@max < as.numeric(length(single_column_digits))){
#print('sfdsff')
#print(head(single_column_digits))
#print(as.numeric(length(single_column_digits)))
print(digitdata@max)
digitdata@max = as.numeric(length(single_column_digits))
#print(digitdata@max)
}
print('hey')
###!!!!!!!!!!!!!!!!!!!!!!!
#remove last digit before remove first, to avoid problems like there are 1-digit numbers
if (skip_last_digit){
single_column_digits = drop_last_digit_places(digitdata, single_column_digits, align_direction)
}
print('gugggma')
if (skip_first_figit){
single_column_digits = drop_first_digit_places(digitdata, single_column_digits, align_direction)
}
print('woooooo')
print(dim(single_column_digits))
digits_table = cbind(digits_table, single_column_digits)
}
return(list('digits_table'=digits_table, 'digitdata'=digitdata))
}
grab_desired_aligned_columns(round_digitdata, data_columns, skip_first_figit, skip_last_digit)
a=grab_desired_aligned_columns(round_digitdata, data_columns, skip_first_figit, skip_last_digit)
a$digitdata@max
#gets the desired data columns for analysis, can be left or right aligned
#also in the mean time drop the first and last digit places if it is desired
grab_desired_aligned_columns = function(digitdata, data_columns, skip_first_figit=TRUE, skip_last_digit=FALSE, align_direction='left'){
digits_table = data.frame(matrix(ncol = 0, nrow = length(digitdata@numbers[,1])))
#handle the data_columns = 'all' situation
data_columns = get_data_columns(digitdata, data_columns)
digitdata@max = 0
for (col_name in data_columns){
single_column_digits = single_column_aligned(digitdata, col_name, align_direction)
#update the max attribute of digitdata for use in other functions
if (digitdata@max < as.numeric(length(single_column_digits))){
#print('sfdsff')
#print(head(single_column_digits))
#print(as.numeric(length(single_column_digits)))
#print(digitdata@max)
digitdata@max = as.numeric(length(single_column_digits))
#print(digitdata@max)
}
###!!!!!!!!!!!!!!!!!!!!!!!
#remove last digit before remove first, to avoid problems like there are 1-digit numbers
if (skip_last_digit){
single_column_digits = drop_last_digit_places(digitdata, single_column_digits, align_direction)
}
if (skip_first_figit){
single_column_digits = drop_first_digit_places(digitdata, single_column_digits, align_direction)
}
digits_table = cbind(digits_table, single_column_digits)
}
return(list('digits_table'=digits_table, 'digitdata'=digitdata))
}
#gets the desired data columns for analysis, can be left or right aligned
#also in the mean time drop the first and last digit places if it is desired
grab_desired_aligned_columns = function(digitdata, data_columns, skip_first_figit=TRUE, skip_last_digit=FALSE, align_direction='left'){
digits_table = data.frame(matrix(ncol = 0, nrow = length(digitdata@numbers[,1])))
#handle the data_columns = 'all' situation
data_columns = get_data_columns(digitdata, data_columns)
digitdata@max = 0
for (col_name in data_columns){
single_column_digits = single_column_aligned(digitdata, col_name, align_direction)
#update the max attribute of digitdata for use in other functions
if (digitdata@max < as.numeric(length(single_column_digits))){
#print('sfdsff')
#print(head(single_column_digits))
#print(as.numeric(length(single_column_digits)))
#print(digitdata@max)
digitdata@max = as.numeric(length(single_column_digits))
#print(digitdata@max)
}
###!!!!!!!!!!!!!!!!!!!!!!!
#remove last digit before remove first, to avoid problems like there are 1-digit numbers
if (skip_last_digit){
single_column_digits = drop_last_digit_places(digitdata, single_column_digits, align_direction)
}
if (skip_first_figit){
single_column_digits = drop_first_digit_places(digitdata, single_column_digits, align_direction)
}
digits_table = cbind(digits_table, single_column_digits)
}
return(list('digits_table'=digits_table, 'digitdata'=digitdata))
}
#gives the table for the left/right aligned table for a single numeric data column ############################
#digitdata is an object of the class DigitAnalysis!                               ############################ Also user friendly, can let user use it to check their data
#desired_col should be a string!
single_column_aligned = function(digitdata, desired_col, align_diretion='left') {
if (is.na(match(desired_col, colnames(digitdata@numbers)))){
#throw error
stop("Specified desired_col is not a numerical data column in the specified DigitAnalysis class object")
} else {
#add a space at the end to avoid picking up alternative superstring column names
checking = paste(desired_col, '')
original_df = NA
if (align_diretion == 'left') {
original_df = digitdata@left_aligned
}
else if (align_diretion == 'right') {
original_df = digitdata@right_aligned
}
else {
stop("align_direction must be either 'left' or 'right'")
}
#create output table
single_align_df = data.frame(matrix(ncol = 0, nrow = length(original_df[,1])))
column_names = colnames(original_df)
for (i in 1:length(column_names)){
if (grepl(checking, column_names[i], fixed=TRUE)){
single_align_df[[column_names[i]]] = NA
single_align_df[[column_names[i]]] = original_df[[column_names[i]]]
}
}
return(single_align_df)
}
}
a=get_round_unround_digitdata(DigitData, unpacking_rounding_column)
round_digitdata = a$round_digitdata
grab_desired_aligned_columns(round_digitdata, data_columns, skip_first_figit, skip_last_digit)
unpacking_round_digit_test(digitdata = DigitData, contingency_table = contingency_table, unpacking_rounding_column, data_columns = data_columns, digit_places = digit_places,
skip_first_figit = skip_first_figit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE,
skip_last_digit=FALSE)
unpacking_round_digit_test = function(digitdata, contingency_table, unpacking_rounding_column, data_columns='all', digit_places='all',
skip_first_figit=FALSE, omit_05=c(0,5), break_out=NA, distribution='Benford', plot=TRUE,
skip_last_digit=FALSE){
#unpack by round numbers indexes in the specified column
lst = get_round_unround_digitdata(digitdata, unpacking_rounding_column)
round_digitdata = lst$round_digitdata
unround_digitdata = lst$unround_digitdata
#perform all digit tests for each digitdata object
round_p_values = all_digits_test(round_digitdata, contingency_table, data_columns, digit_places, skip_first_figit,
omit_05, break_out, distribution, plot, skip_last_digit, unpacking_rounding_column)
unround_p_values = all_digits_test(unround_digitdata, contingency_table, data_columns, digit_places, skip_first_figit,
omit_05, break_out, distribution, plot, skip_last_digit, unpacking_rounding_column)
#merge the results
p_values = rbind(round_p_values, unround_p_values)
print('heyhey fuck here')
rownames(p_values) = c('round', 'unround')
return(p_values)
}
unpacking_round_digit_test(digitdata = DigitData, contingency_table = contingency_table, unpacking_rounding_column, data_columns = data_columns, digit_places = digit_places,
skip_first_figit = skip_first_figit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE,
skip_last_digit=FALSE)
result = all_digits_test(digitdata = DigitData, contingency_table = contingency_table, data_columns = data_columns, digit_places = digit_places,
skip_first_figit = skip_first_figit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE,
skip_last_digit=FALSE, unpacking_rounding_column=unpacking_rounding_column)
unpacking_round_digit_test = function(digitdata, contingency_table, unpacking_rounding_column, data_columns='all', digit_places='all',
skip_first_figit=FALSE, omit_05=c(0,5), break_out=NA, distribution='Benford', plot=TRUE,
skip_last_digit=FALSE){
#unpack by round numbers indexes in the specified column
lst = get_round_unround_digitdata(digitdata, unpacking_rounding_column)
round_digitdata = lst$round_digitdata
unround_digitdata = lst$unround_digitdata
#perform all digit tests for each digitdata object
round_p_values = all_digits_test(round_digitdata, contingency_table, data_columns, digit_places, skip_first_figit,
omit_05, break_out, distribution, plot, skip_last_digit, unpacking_rounding_column=NA)
unround_p_values = all_digits_test(unround_digitdata, contingency_table, data_columns, digit_places, skip_first_figit,
omit_05, break_out, distribution, plot, skip_last_digit, unpacking_rounding_column=NA)
#merge the results
p_values = rbind(round_p_values, unround_p_values)
print('heyhey fuck here')
rownames(p_values) = c('round', 'unround')
return(p_values)
}
unpacking_rounding_column='ALEXP'
unpacking_round_digit_test(digitdata = DigitData, contingency_table = contingency_table, unpacking_rounding_column, data_columns = data_columns, digit_places = digit_places,
skip_first_figit = skip_first_figit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE,
skip_last_digit=FALSE)
############################################################
#Testing; run the functions
#Wenjun Chang
#Summer 2020
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
#force numerical representation rather than scientific
#options(scipen = 999)
options(scipen = 1)
options(digits = 2)
##############################
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load chi square test GOF functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\chi_square_goodness_of_fit_functions.R')
#load main function for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_main_function.R')
#load functionS for unpack round numbers test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\unpack_round_numbers_test.R')
#load all functions for digit pair test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\digit_pair_test.R')
#load all functions for rounding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\rounding_test.R')
#load all functions for repeat test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\repeat_test.R')
#load all functions for high low test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\high_low_test.R')
#load all functions for padding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\padding_test.R')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#############################################################
#############try it with given data##########################
#############################################################
#test data input and benford table functions
#load data input functions
data_columns = c("ALEXP","BENTOT", "BENM", "BENF")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
contingency_table
#test all digits test
data_columns = 'all'#'ALEXP'
digit_places =  'all'# c(1,2,3)
skip_first_figit=TRUE
omit_05 = c(0,5)
break_out='DIST'
# distribution='Benford'
# plot=TRUE
skip_last_digit=FALSE
result = all_digits_test(digitdata = DigitData, contingency_table = contingency_table, data_columns = data_columns, digit_places = digit_places,
skip_first_figit = skip_first_figit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE, skip_last_digit = skip_last_digit)
#test unpack round numbers test
unpacking_rounding_column='ALEXP'
data_columns = 'all'#'ALEXP'
digit_places =  'all'# c(1,2,3)
skip_first_figit=TRUE
omit_05 = c(0,5)
break_out='DIST'
# distribution='Benford'
# plot=TRUE
skip_last_digit=FALSE
unpack = unpack_round_numbers_test(digitdata = DigitData, contingency_table = contingency_table, unpacking_rounding_column = unpacking_rounding_column, data_columns = data_columns,
digit_places = digit_places, skip_first_figit = skip_first_figit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE,
skip_last_digit = skip_last_digit)
unpack_round_numbers_test(digitdata = DigitData, contingency_table = contingency_table, unpacking_rounding_column = unpacking_rounding_column, data_columns = data_columns,
digit_places = digit_places, skip_first_figit = skip_first_figit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE,
skip_last_digit = skip_last_digit)
class(DigitData)
class(DigitData)[1]
class(DigitData)[1] == 'DigitAnalysis'
############################################################
#Functions for digit analysis R package
###digit pair test functions in this file
#Wenjun Chang
#Summer 2020
############################################################
############################################################
#some helper functions
############################################################
#find the frequency of terminal digit pairs occuring in the data being analzyed
#return a vector of [# pairs, # not pairs]
counts_observed = function(digitdata, data_columns, omit_05, min_length, indexes=NA){
occurances = data.frame(matrix(nrow = 0, ncol = 2))
for (desired_col in data_columns){
digit_pair_table = single_column_aligned(digitdata, desired_col, align_diretion='right')
#for break out, we separate into categories by indexing
if (!(is.na(indexes[1]))){ ####might have bug here...did [1] to get rid of warnings
digit_pair_table = digit_pair_table[indexes, ]
}
#remove all numbers that has length less than min_length
#only the last three digits
digit_pair_table = digit_pair_table[(ncol(digit_pair_table)-min_length+1):ncol(digit_pair_table)]
##remove incomplete rows (with nans/length < min_length)
digit_pair_table = digit_pair_table[complete.cases(digit_pair_table), ]
#only use last two digits
digit_pair_table = digit_pair_table[(ncol(digit_pair_table)-1):ncol(digit_pair_table)]
#need to coerce the names to be identical before rbind
colnames(digit_pair_table) = colnames(occurances)
#update
occurances = rbind(occurances, digit_pair_table)
}
#paste the last tywo digits together as numbers
occurances = as.numeric(paste(occurances[,1], occurances[,2], sep=''))
pairs = c('00', '11', '22', '33', '44', '55', '66', '77', '88', '99')
if (!(is.na(omit_05[1]))){
#we omit 00 as part of digit pair
pairs = pairs[-1]
}
#find the counts for all digit pairs
counts = table(occurances)
counts = sum(counts[pairs[pairs %in% names(counts)]])
# #derive the frequency
# freq_pairs = counts / sum(occurances)
return(c(counts, sum(occurances) - counts))
}
#get the theoratical frequency of terminal digit pair frequency
freq_true = function(omit_05){
total = 100 #100 combinations possible
pairs = 10 #10 pairs possible
if (length(omit_05) == 1){
if (!(is.na(omit_05))){
#omitting 0, so omit 00 pair as option
total = total - 1
pairs = pairs - 1
}
else {
#omitting both 0 and 5, so omit 00 pair and 50 as option
total = total - 2
pairs = pairs - 1
}
}
return(pairs/total)
}
################main function############
#performs terminal digit pair binomial test vs uniform distribution (Benford’s Law)
#digitdata is the class object;
#data_columns are the names of numerical columns of data to be analyzed (defaulted as 'all' to the entire number table)
#omit_05 has three options: omit both 0 and 5->c(0,5)/c(5,0); omit only 0->0 or c(0); and omit neither->NA (when no rounding test is performed)
#if analysis by groups is desired, break_out should specify the deisred category to break upon
#distribution can be 'Benford' or 'Uniform' or more ???
####
#need ADD distribution and plot parameter
####
digit_pairs_test = function(digitdata, data_columns='all', omit_05=c(0,5), min_length=3, break_out=NA){
#checkings
if (length(omit_05) == 1){
###check omit only 5, which is not allowed
if (!(is.na(omit_05)) && (omit_05 == 5)){
stop('cannot omit only 5 without also omitting 0 first')
}
}
if (is.na(min_length)){
stop('min length must be an integer >= 2')
}
else if (min_length < 2){
stop('min length must be an integer >= 2')
}
#get the theoratical frequency based on Benford's Law --> Uniform Distribution
p = freq_true(omit_05)
#handle the data_columns = 'all' situation
data_columns = get_data_columns(digitdata, data_columns)
#get the observed counts for number of terminal digit pairs
counts = counts_observed(digitdata, data_columns, omit_05, min_length)
#get p_value from binomial test
p_value = binom.test(counts, p = p)$p.value #has to specify p = p !!!!!!
#a dataframe of p values to return
p_values = data.frame(all=p_value)
if (!(is.na(break_out))){
#get indexes for each category
indexes_of_categories = break_by_category(digitdata@cleaned, break_out) #this is a list since unequal number of entries for each category
#break by category for all
for (category_name in names(indexes_of_categories)){
indexes_of_category = indexes_of_categories[[category_name]]
counts_in_category = counts_observed(digitdata, data_columns, omit_05, min_length, indexes_of_category)
p_value_in_category = binom.test(counts_in_category, p)$p.value
p_values[category_name] = p_value_in_category
}
}
return(p_values)
}
#test digit pair test
min_length = 3
omit_05 = NA
data_columns = c("ALEXP")#,"BENTOT", "BENM", "BENF")
break_out = 'DIST'
digit_pairs_test(DigitData, data_columns, omit_05, min_length, break_out)
#test digit pair test
min_length = 3
omit_05 = NA
data_columns = c("ALEXP","BENTOT", "BENM", "BENF")
break_out = 'DIST'
digit_pairs_test(DigitData, data_columns, omit_05, min_length, break_out)
a=c(NA, 0, c(0,5))
a
a = list(NA, 0, c(0,5))
a
0 in a
0 %in% a
c(0,5) %in% a
NA %in% a
switch(NA, 0, c(0,5))
a=switch(NA, 0, c(0,5))
a
c(0,5)=c(0,0)
stopifnot(class(DigitData)[1] == 'DigitAnalysis')
stopifnot(class(a)[1] == 'DigitAnalysis')
print(("digitdata must be an object in the class DigitAnalysis.\nCheck function make_class()"))
cat("digitdata must be an object in the class DigitAnalysis.\nCheck function make_class()"))
cat("digitdata must be an object in the class DigitAnalysis.\nCheck function make_class()")
if (class(a)[1] != 'DigitAnalysis'){
stop(cat("digitdata must be an object in the class DigitAnalysis.\nCheck function make_class()"))
}
if (class(a)[1] != 'DigitAnalysis'){
stop(cat("digitdata must be an object in the class DigitAnalysis.\nCheck function make_class()"))}
if (class(digitdata)[1] != 'DigitAnalysis'){
stop("digitdata must be an object in the class DigitAnalysis.Check function make_class()")}
if (class(a)[1] != 'DigitAnalysis'){
stop("digitdata must be an object in the class DigitAnalysis.Check function make_class()")}
help("tryCatch")
