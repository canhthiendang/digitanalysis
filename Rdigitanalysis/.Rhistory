'8th digit', '9th digit', '10th digit', '11th digit', '12th digit', '13th digit')
right_aligned_column_names = c('1s', '10s', '100s', '1k', '10k', '100k', '1m', '10m', '100m', '1b', '10b', '100b', '1t')
####################################
############important###############
####################################
########################creation of all sub-objects########################
cleaned_data = make_cleaned_data(raw_data, col_analyzing)
cleaned_data = cleaned_data[complete.cases(cleaned_data['ALEXP.Values']), ] #### for now
print('3')
numeric_data = make_numeric_data(cleaned_data, col_analyzing)
#the dataframe with the left aligned digits of each data column to be analyzed->'left_aligned' of the class
#i.e. a column is 'X'; first digit will be at column '1st digit' + 'X'
left_aligned_data = make_aligned_data(cleaned_data, col_analyzing, naming_method=left_aligned_column_names, align_direction='left')
#the dataframe with the right aligned digits of each data column to be analyzed->'right_aligned' of the class
#i.e. a column is 'X'; first digit will be at column '1s' + 'X'
right_aligned_data = make_aligned_data(cleaned_data, col_analyzing, naming_method=right_aligned_column_names, align_direction='right')
#reverse the dataframe for better visual in normal form
right_aligned_data = rev(right_aligned_data)
########################creation of DigitAnalysis class object########################
DigitData = DigitAnalysis(raw=raw_data, cleaned=cleaned_data, numbers=numeric_data, left_aligned=left_aligned_data, right_aligned=right_aligned_data,
left_aligned_column_names=left_aligned_column_names, right_aligned_column_names=right_aligned_column_names, max=0)
return(DigitData)
}
#test data input and benford table functions
#load data input functions
data_columns = c("ALEXP.Values")#,"BENTOT", "BENM", "BENF")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL 2.csv'
#test = read.csv('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL 2.csv', stringsAsFactors=FALSE)
# omitting_index = which(is.na(test$ALEXP.Values))
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
# omitting_index
#
# DigitData_match = DigitData
# DigitData_match@cleaned = DigitData_match@cleaned[-omitting_index, ]
# DigitData_match@numbers = data.frame(DigitData_match@numbers[-omitting_index, ])
# colnames(DigitData_match@numbers) = colnames(DigitData@numbers)
#
# DigitData_match@left_aligned = DigitData_match@left_aligned[-omitting_index, ]
# DigitData_match@right_aligned = DigitData_match@right_aligned[-omitting_index, ]
#
# a=test$ALEXP.Values
# length(which(!(is.na(a))))
# length(omitting_index)+length(which(!(is.na(a))))
# dim(DigitData_match@cleaned)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
# contingency_table = contingency_table[!colnames(contingency_table) %in% c('a', 'X')]
# contingency_table
# saveRDS(contingency_table, file = "benford_table.RData")
# readRDS(file = "benford_table.RData")
#test all digits test
data_columns = 'ALEXP.Values'
digit_places =  'all'#c(2,3,4,5,6,7)#'all'# c(1,2,3)
skip_first_digit=TRUE
omit_05 = c(0,5)
break_out='DIST'
# distribution='Benford'
# plot=TRUE
skip_last_digit=FALSE
result = all_digits_test(digitdata = DigitData, contingency_table = contingency_table, data_columns = data_columns, digit_places = digit_places,
skip_first_digit = skip_first_digit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE, skip_last_digit = skip_last_digit)
complete.cases(DigitData@cleaned_data['ALEXP.Values'])
complete.cases(DigitData@cleaned['ALEXP.Values'])
which(complete.cases(DigitData@cleaned['ALEXP.Values']))
############################################################
#Functions for digit analysis R package
###Data input functions in this file
#Wenjun Chang
#Summer 2020
############################################################
############################################################
#Class function
############################################################
#create our own class
DigitAnalysis = setClass('DigitAnalysis', slots = c(raw="data.frame", cleaned="data.frame",
numbers="data.frame", left_aligned="data.frame",
right_aligned="data.frame", left_aligned_column_names='character',
right_aligned_column_names='character', max='numeric'))
############################################################
#basic helper functions for data input function
############################################################
#this thing blow up my storage several times for some reason??????
#library("readxl")
#xlxs = read_excel('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.xlsx')
#rounding function based on user preference
round_data = function(data, method='round'){
if (method == 'round'){
return(round(data))
} else if (method == 'floor'){
return(floor(data))
} else if (method == 'ceiling'){
return(ceiling(data))
}
}
#find the length of the largest number in a data column
max_length = function(data){
max = max(floor(log10(data[!(is.na(data))]))+1)
# max = 0
# for (i in 1:length(data)){
#   if (!(is.na(data[i]))) {
#     if (floor(log10(data[i]))+1 > max){
#       max = floor(log10(data[i]))+1
#     }
#   }
# }
return(max)
}
#drop rows with NaNs or empty strings in any numeric data column
# drop_nan_empty = function(df, col_conerned){
#   output = data.frame(df)
#   output = complete.cases(output[col_conerned]) #?? not sure if this work
#   # for (i in 1:length(col_conerned)){
#   #   output = output[!(is.na(output[[col_conerned[i]]]) | output[[col_conerned[i]]]==""), ]
#   # }
#   return(output)
# }
#align the digits from the left/right of a data column and update it to the specified data frame
align_digits = function(indata, outdata, naming_method, colname, align_direction='left'){
max = max_length(indata) #max length of largest number in indata
#intialize all digit places to NA
for (i in 1:max){
outdata[[paste(colname, naming_method[i])]] = NA
}
for (j in 1:length(indata)){
#split each number into chars
if (!(is.na(indata[j]))){
chars = strsplit(as.character(indata[j]), "")[[1]]
#reverse it since we are aligning from the right so right-first digit comes first
if (align_direction == 'right'){
chars = rev(chars)
}
for (k in 1:length(chars)){
outdata[[paste(colname, naming_method[k])]][j] = as.integer(chars[k])
}
}
}
return(outdata)
}
############################################################
#intermediate helper functions for data input function
############################################################
#clean up the number columns with numeric data to be analyzed->'cleaned' of the class
make_cleaned_data = function(raw_data, col_analyzing){
cleaned_data = data.frame(raw_data) #make copy without pointer issue
#drop rows with NaNs or empty strings in any numeric data column
# cleaned_data = drop_nan_empty(cleaned_data, col_analyzing)
for (i in 1:length(col_analyzing)) {
#name of current data column modifying
col_name = col_analyzing[i]
#turn into numbers
cleaned_data[[col_name]] = as.numeric(gsub(",","",as.character(cleaned_data[[col_name]]), fixed=TRUE))
#rounding
cleaned_data[[col_name]] = round_data(cleaned_data[[col_name]])
}
return(cleaned_data)
}
#the dataframe with only the data being analyzed->'numeric' of the class
make_numeric_data = function(cleaned_data, col_analyzing){
#initialization
numeric_data = data.frame(matrix(ncol = 0, nrow = length(cleaned_data[,1])))
for (i in 1:length(col_analyzing)) {
#name of current data column modifying
col_name = col_analyzing[i]
#update 'numeric' object
numeric_data[[col_name]] = NA
numeric_data[[col_name]] = cleaned_data[[col_name]]
}
return(numeric_data)
}
#the dataframe with the left/right aligned digits of each data column to be analyzed->'left_aligned'/'right_aligned' of the class
make_aligned_data = function(cleaned_data, col_analyzing, naming_method, align_direction='left'){
#initialization
aligned_data = data.frame(matrix(ncol = 0, nrow = length(cleaned_data[,1])))
for (i in 1:length(col_analyzing)) {
#name of current data column modifying
col_name = col_analyzing[i]
#update by 'align_left' or 'align_right'
indata = cleaned_data[[col_name]]
#replace 0 by NA for digit analysis
indata[indata == 0] = NA
aligned_data = align_digits(indata=indata, outdata=aligned_data, naming_method=naming_method, colname=col_name, align_direction=align_direction) ###NAs introduced by coercion
}
return(aligned_data)
}
#make_aligned_data(DigitData@cleaned, 'ALEXP', DigitData@right_aligned_column_names, align_direction='right')
############################################################
#Data input main function
############################################################
###parse and clean the data for digit analysis
###col_analyzing can be specified as any of numeric_data='sdfsfsf' or numeric_data=c('dsdfsfsf') or numeric_data=c('dsdfsfsf',...)
###option to use delimeters with ',' as default
#filetype can be csv or excel
make_class = function(filepath, col_analyzing, delim=',', filetype='csv'){
#data format: row is observation; column is category; must be csv!!!
#raw input data->'raw' of the class
raw_data = NA
print('0')
if (filetype == 'csv'){
raw_data = read.csv(filepath, sep=delim, stringsAsFactors=FALSE)
}
else if (filetype == 'excel'){
raw_data = readxl::read_excel(filepath) #really bad...takes 10 mins to load
raw_data = data.frame(raw_data) #turn to dataframe..before is some weird type called tibble
}
else {
stop('input file must be either csv or excel (.xls or .xlsx) file')
}
print('1')
#remove all unnecessary blank columns
raw_data = raw_data[colSums(!is.na(raw_data)) > 0]
print('2')
####################################
############important###############
####################################
#hard-coded way of naming the digit places, should be sufficient, if not can further add
left_aligned_column_names = c('1st digit', '2nd digit', '3rd digit', '4th digit', '5th digit', '6th digit', '7th digit',
'8th digit', '9th digit', '10th digit', '11th digit', '12th digit', '13th digit')
right_aligned_column_names = c('1s', '10s', '100s', '1k', '10k', '100k', '1m', '10m', '100m', '1b', '10b', '100b', '1t')
####################################
############important###############
####################################
########################creation of all sub-objects########################
cleaned_data = make_cleaned_data(raw_data, col_analyzing)
cleaned_data = cleaned_data[which(complete.cases(cleaned_data['ALEXP.Values'])), ] #### for now
print('3')
numeric_data = make_numeric_data(cleaned_data, col_analyzing)
#the dataframe with the left aligned digits of each data column to be analyzed->'left_aligned' of the class
#i.e. a column is 'X'; first digit will be at column '1st digit' + 'X'
left_aligned_data = make_aligned_data(cleaned_data, col_analyzing, naming_method=left_aligned_column_names, align_direction='left')
#the dataframe with the right aligned digits of each data column to be analyzed->'right_aligned' of the class
#i.e. a column is 'X'; first digit will be at column '1s' + 'X'
right_aligned_data = make_aligned_data(cleaned_data, col_analyzing, naming_method=right_aligned_column_names, align_direction='right')
#reverse the dataframe for better visual in normal form
right_aligned_data = rev(right_aligned_data)
########################creation of DigitAnalysis class object########################
DigitData = DigitAnalysis(raw=raw_data, cleaned=cleaned_data, numbers=numeric_data, left_aligned=left_aligned_data, right_aligned=right_aligned_data,
left_aligned_column_names=left_aligned_column_names, right_aligned_column_names=right_aligned_column_names, max=0)
return(DigitData)
}
############################################################
#Testing; run the functions
#Wenjun Chang
#Summer 2020
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
#force numerical representation rather than scientific
#options(scipen = 999)
options(scipen = 1)
options(digits = 2)
##############################
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load chi square test GOF functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\chi_square_goodness_of_fit_functions.R')
#load main function for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_main_function.R')
#load functionS for unpack round numbers test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\unpack_round_numbers_test.R')
#load all functions for digit pair test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\digit_pair_test.R')
#load all functions for rounding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\rounding_test.R')
#load all functions for repeat test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\repeat_test.R')
#load all functions for high low test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\high_low_test.R')
#load all functions for padding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\padding_test.R')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function.R')
#############################################################
#############try it with given data##########################
#############################################################
#test data input and benford table functions
#load data input functions
data_columns = c("ALEXP.Values")#,"BENTOT", "BENM", "BENF")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL 2.csv'
#test = read.csv('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL 2.csv', stringsAsFactors=FALSE)
# omitting_index = which(is.na(test$ALEXP.Values))
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
# omitting_index
#
# DigitData_match = DigitData
# DigitData_match@cleaned = DigitData_match@cleaned[-omitting_index, ]
# DigitData_match@numbers = data.frame(DigitData_match@numbers[-omitting_index, ])
# colnames(DigitData_match@numbers) = colnames(DigitData@numbers)
#
# DigitData_match@left_aligned = DigitData_match@left_aligned[-omitting_index, ]
# DigitData_match@right_aligned = DigitData_match@right_aligned[-omitting_index, ]
#
# a=test$ALEXP.Values
# length(which(!(is.na(a))))
# length(omitting_index)+length(which(!(is.na(a))))
# dim(DigitData_match@cleaned)
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
# contingency_table = contingency_table[!colnames(contingency_table) %in% c('a', 'X')]
# contingency_table
# saveRDS(contingency_table, file = "benford_table.RData")
# readRDS(file = "benford_table.RData")
#test all digits test
data_columns = 'ALEXP.Values'
digit_places =  'all'#c(2,3,4,5,6,7)#'all'# c(1,2,3)
skip_first_digit=TRUE
omit_05 = c(0,5)
break_out='DIST'
# distribution='Benford'
# plot=TRUE
skip_last_digit=FALSE
result = all_digits_test(digitdata = DigitData, contingency_table = contingency_table, data_columns = data_columns, digit_places = digit_places,
skip_first_digit = skip_first_digit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE, skip_last_digit = skip_last_digit)
test = read.csv('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL 2.csv', stringsAsFactors=FALSE)
excel = strsplit(as.character(test$ALEXP.Values), '')
excel
num_digits = 0
baringo_digits = strsplit(as.character(baringo_numbers), '')
all = strsplit(as.character(d), '')
excel = strsplit(as.character(test$ALEXP.Values), '')
for (i in excel){
# # count first digit
# if (! i[1] %in% c('5', '0')){
# num_digits = num_digits + 1
# }
# skip first
if (!(is.na(i))){
ii = i[-1]
iii = ii[!ii %in% c('5', '0')]
num_digits = num_digits + length(iii)
print(iii)
}
}
length(character(0))
num_digits
#excel = strsplit(as.character(DigitData@numbers), '')
length(excel)
which(!is.na(test$ALEXP.Values))
length(which(!is.na(test$ALEXP.Values)))
View(DigitData)
test$ALEXP.Values[which(!is.na(test$ALEXP.Values))]
#test unpack round numbers test
unpacking_rounding_column='ALEXP'
numbers = test$ALEXP.Values[which(!is.na(test$ALEXP.Values))]
strsplit(as.character(numbers), '')
d = DigitData@numbers
d
all = strsplit(as.character(d), '')
all
d = DigitData@numbers[[1]]
d
all = strsplit(as.character(d), '')
all
for (i in all){
# # count first digit
# if (! i[1] %in% c('5', '0')){
# num_digits = num_digits + 1
# }
# skip first
if (!(is.na(i))){
ii = i[-1]
iii = ii[!ii %in% c('5', '0')]
num_digits = num_digits + length(iii)
print(iii)
}
}
warnings()
num_digits = 0
for (i in all){
# # count first digit
# if (! i[1] %in% c('5', '0')){
# num_digits = num_digits + 1
# }
# skip first
if (!(is.na(i))){
ii = i[-1]
iii = ii[!ii %in% c('5', '0')]
num_digits = num_digits + length(iii)
print(iii)
}
}
num_digits
num_digits = 0
for (i in all){
# # count first digit
# if (! i[1] %in% c('5', '0')){
# num_digits = num_digits + 1
# }
# skip first
if (!(is.na(i))){
ii = i[-1]
iii = ii[!ii %in% c('5', '0')]
num_digits = num_digits + length(iii)
print(iii)
}
}
num_digits
numbers = test$ALEXP.Values[which(!is.na(test$ALEXP.Values))]
length(numbers)
numbers == d
False %in% numbers == d
FALSE %in% numbers == d
FALSE %in% [numbers == d]
table(numbers == d)
excel = strsplit(as.character(test$ALEXP.Values), '')
num_digits = 0
baringo_digits = strsplit(as.character(baringo_numbers), '')
all = strsplit(as.character(d), '')
excel = strsplit(as.character(test$ALEXP.Values), '')
for (i in all){
# # count first digit
# if (! i[1] %in% c('5', '0')){
# num_digits = num_digits + 1
# }
# skip first
if (!(is.na(i))){
ii = i[-1]
iii = ii[!ii %in% c('5', '0')]
num_digits = num_digits + length(iii)
print(iii)
}
}
num_digits
numbers = test$ALEXP.Values[which(!is.na(test$ALEXP.Values))]
num_digits = 0
baringo_digits = strsplit(as.character(baringo_numbers), '')
all = strsplit(as.character(d), '')
excel = strsplit(as.character(test$ALEXP.Values), '')
for (i in all){
# # count first digit
# if (! i[1] %in% c('5', '0')){
# num_digits = num_digits + 1
# }
# skip first
if (!(is.na(i))){
ii = i[-1]
iii = ii[!ii %in% c('5', '0')]
num_digits = num_digits + length(iii)
print(iii)
}
}
num_digits
test = read.csv('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL 2.csv', stringsAsFactors=FALSE)
excel = strsplit(as.character(test$ALEXP.Values), '')
for (i in excel){
# # count first digit
# if (! i[1] %in% c('5', '0')){
# num_digits = num_digits + 1
# }
# skip first
if (!(is.na(i))){
ii = i[-1]
iii = ii[!ii %in% c('5', '0')]
num_digits = num_digits + length(iii)
print(iii)
}
}
num_digits
num_digits = 0
excel = strsplit(as.character(test$ALEXP.Values), '')
for (i in excel){
# # count first digit
# if (! i[1] %in% c('5', '0')){
# num_digits = num_digits + 1
# }
# skip first
if (!(is.na(i))){
ii = i[-1]
iii = ii[!ii %in% c('5', '0')]
num_digits = num_digits + length(iii)
print(iii)
}
}
num_digits
d = DigitData@numbers[[1]]
num_digits = 0
baringo_digits = strsplit(as.character(baringo_numbers), '')
all = strsplit(as.character(d), '')
for (i in all){
# # count first digit
# if (! i[1] %in% c('5', '0')){
# num_digits = num_digits + 1
# }
# skip first
if (!(is.na(i))){
ii = i[-1]
iii = ii[!ii %in% c('5', '0')]
num_digits = num_digits + length(iii)
print(iii)
}
}
num_digits
numbers = test$ALEXP.Values[which(!is.na(test$ALEXP.Values))]
length(numbers)
table(numbers == d)
which(numbers==0)
length(DigitData@left_aligned)
length(DigitData@left_aligned[[1]])
strsplit(as.character(1451), "")
d
all
rev(all)
all
as.integer(strsplit(as.character(1451), "")[[1]])
strsplit(as.character(NA), "")
strsplit(as.character(''), "")
