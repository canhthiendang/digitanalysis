}
}
#break_out must be a string specifying a column name in the data
if (TRUE %in% (!(is.na(break_out)))){
if (!(is.character(break_out))){
stop('break_out must be a string specifying a column name in the data!')
}
}
#distribution must be either 'Benford' or 'Uniform'
if (TRUE %in% (!(is.na(distribution)))){
if (!(distribution %in% c('Benford', 'Uniform'))){
stop("distribution must be either 'Benford' or 'Uniform'!")
}
}
#plot must be a boolean: TRUE or FALSE
if (TRUE %in% (!(is.na(plot)))){
if (!(is.logical(plot))){
stop('plot must be a boolean: TRUE or FALSE!')
}
}
#skip_last_digit must be a boolean: TRUE or FALSE
if (TRUE %in% (!(is.na(skip_last_digit)))){
if (!(is.logical(skip_last_digit))){
stop('skip_last_digit must be a boolean: TRUE or FALSE!')
}
#if doing last digit test, should not skip_last_digit
if (TRUE %in% (!(is.na(digit_places)))){
if (length(digit_places) == 1){
if (digit_places == -1){
if (skip_last_digit){
stop('skip_last_digit while doing a last digit test: contradiction!')
}
}
}
}
}
#unpacking_rounding_column must be a string specifying a column name in the data
if (TRUE %in% (!(is.na(unpacking_rounding_column)))){
if (!(is.character(unpacking_rounding_column))){
stop('unpacking_rounding_column must be a string specifying a column name in the data!')
}
}
#min_length must be an integer denoting the minimum length of the numbers to be analyzed in digit pair test
if (TRUE %in% (!(is.na(min_length)))){
if (length(min_length) != 1){
stop("min_length must be an integer denoting the minimum length of the numbers to be analyzed in digit pair test!")
}
else if (!(is.numeric(min_length))){
stop("min_length must be an integer denoting the minimum length of the numbers to be analyzed in digit pair test!")
}
}
#duplicate_matching_cols must be a single column name or an array of column names to define a exact duplicate
if (TRUE %in% (!(is.na(duplicate_matching_cols)))){
if (duplicate_matching_cols != 'all'){
if (!(is.character(duplicate_matching_cols))){
stop("duplicate_matching_cols must be a single column name or an array of column names to define a exact duplicate!")
}
}
}
#sector_column must be a string specifying a column name in the data
if (TRUE %in% (!(is.na(sector_column)))){
if (!(is.character(sector_column))){
stop('sector_column must be a string specifying a column name in the data!')
}
}
#sector_grouping must be a list specifying the columns in each sector intended to split upo
if (TRUE %in% (!(is.na(sector_grouping)))){
if (!(is.list(sector_grouping))){
stop('sector_grouping must be a list specifying the columns in each sector intended to split upon!')
}
}
# need add this option later
# #"failure_factor must be an integer denoting the factor that one must exceed the other sector to be categorized as failure of the sector test
# if (TRUE %in% (!(is.na(failure_factor)))){
#   if (length(failure_factor) != 1){
#     stop("failure_factor must be an integer denoting the factor that one must exceed the other sector to be categorized as failure of the sector test!")
#   }
#   else if (!(is.numeric(failure_factor))){
#     stop("failure_factor must be an integer denoting the factor that one must exceed the other sector to be categorized as failure of the sector test!")
#   }
# }
#high must be a single digit place integer or an array of digit places specifying the digits that are classified as high digits
if (TRUE %in% (!(is.na(high)))){
if (!(is.numeric(high))){
stop("high must be a single digit place integer or an array of digit places specifying the digits that are classified as high digits!")
}
}
#########################################################
##########add the 05 option testing for rounding test
#########################################################
#max_length must be an integer denoting the maximum length of the numbers to be analyzed in padding test
if (TRUE %in% (!(is.na(max_length)))){
if (length(max_length) != 1){
stop("max_length must be an integer denoting the maximum length of the numbers to be analyzed in padding test!")
}
else if (!(is.numeric(max_length))){
stop("max_length must be an integer denoting the maximum length of the numbers to be analyzed in padding test!")
}
}
#num_digits must be an integer denoting the number of digits from the right to be to be analyzed in padding test
if (TRUE %in% (!(is.na(num_digits)))){
if (length(num_digits) != 1){
stop("num_digits must be an integer denoting the number of digits from the right to be to be analyzed in padding test!")
}
else if (!(is.numeric(num_digits))){
stop("num_digits must be an integer denoting the number of digits from the right to be to be analyzed in padding test!")
}
}
#N must be an integer denoting the number of datasets to be stimulated from Monte Carlo Process in padding test
if (TRUE %in% (!(is.na(N)))){
if (length(N) != 1){
stop("N must be an integer denoting the number of datasets to be stimulated from Monte Carlo Process in padding test!")
}
else if (!(is.numeric(N))){
stop("N must be an integer denoting the number of datasets to be stimulated from Monte Carlo Process in padding test!")
}
}
}
input_check(a)
input_check(DigitData)
############################################################
#Functions for digit analysis R package
###input check function in this file
#Wenjun Chang
#Summer 2020
############################################################
############################################################
#input check function
############################################################
#assert the input to user accessible functions in this package are of correct type and form
#digitdata is mandatory option, all other arguemnts are defaulted to NA, and checked iff it is relevant
input_check = function(digitdata, contingency_table=NA, data_columns=NA, digit_places=NA, skip_first_digit=NA, omit_05=NA, break_out=NA,
distribution=NA, plot=NA, skip_last_digit=NA, unpacking_rounding_column=NA, min_length=NA, duplicate_matching_cols=NA,
sector_column=NA, sector_grouping=NA, high=NA, max_length=NA, num_digits=NA, N=NA) {
#############some logical stuff to check and throw errors on###########
#digitdata must be of class DigitAnalysis
if (class(digitdata)[1] != 'DigitAnalysis'){
stop("digitdata must be an object in the class DigitAnalysis! check function make_class()!")
}
#contingency_table must be a dataframe
if (TRUE %in% (!(is.na(contingency_table)))){
if (!(is.data.frame(contingency_table))){
stop("contingency_table must be a dataframe!")
}
}
#data_columns must be either 'all', a single column name, or an array of column names desired to analyze
if (TRUE %in% (!(is.na(data_columns)))){
if (data_columns != 'all'){
if (!(is.character(data_columns))){
stop("data_columns must be either 'all', a single column name, or an array of column names desired to analyze!")
}
}
}
#check digit_places
if (TRUE %in% (!(is.na(digit_places)))){
#digit_places must be either 'all', a single digit place integer, or an array of digit places desired to analyze
if (digit_places != 'all'){
if (!(is.numeric(digit_places))){
stop("digit_places must be either 'all', a single digit place integer, or an array of digit places desired to analyze!")
}
#multiple digit places test cannot have -1 as part of the array
if (length(digit_places) > 1){
if (!is.na(match(-1, digit_places))){
stop('multiple digits test cannot have last digit as part of the digit places input!')
}
}
}
#should not have 1 as part of digit_places if we are skipping first digit place using skip_first_digit
if (TRUE %in% (!(is.na(skip_first_digit)))){
if (skip_first_digit){
if (!is.na(match(1, digit_places))){
stop('digit_places and skip_first_digit contradicts, both looking and not looking at the first digit place!')
}
}
}
}
#skip_first_digit must be a boolean: TRUE or FALSE
if (TRUE %in% (!(is.na(skip_first_digit)))){
if (!(is.logical(skip_first_digit))){
stop('skip_first_digit must be a boolean: TRUE or FALSE!')
}
}
#omit_05 must be either NA, 0, c(0,5), or c(5,0)
if (TRUE %in% (!(is.na(omit_05)))){
if (length(omit_05) == 1){
#must be 0
if (omit_05 != 0){
stop('omit_05 must be either NA, 0, c(0,5), or c(5,0)')
}
}
else if (length(omit_05) == 2){
#0 and 5 should be the two elements
if (length(omit_05[omit_05 != 5]) != 1){
stop('omit_05 must be either NA, 0, c(0,5), or c(5,0)')
}
else if (omit_05[omit_05 != 5] != 0){
stop('omit_05 must be either NA, 0, c(0,5), or c(5,0)')
}
}
#3 elements does not make sense
else {
stop('omit_05 must be either NA, 0, c(0,5), or c(5,0)')
}
}
#break_out must be a string specifying a column name in the data
if (TRUE %in% (!(is.na(break_out)))){
if (!(is.character(break_out))){
stop('break_out must be a string specifying a column name in the data!')
}
}
#distribution must be either 'Benford' or 'Uniform'
if (TRUE %in% (!(is.na(distribution)))){
if (!(distribution %in% c('Benford', 'Uniform'))){
stop("distribution must be either 'Benford' or 'Uniform'!")
}
}
#plot must be a boolean: TRUE or FALSE
if (TRUE %in% (!(is.na(plot)))){
if (!(is.logical(plot))){
stop('plot must be a boolean: TRUE or FALSE!')
}
}
#skip_last_digit must be a boolean: TRUE or FALSE
if (TRUE %in% (!(is.na(skip_last_digit)))){
if (!(is.logical(skip_last_digit))){
stop('skip_last_digit must be a boolean: TRUE or FALSE!')
}
#if doing last digit test, should not skip_last_digit
if (TRUE %in% (!(is.na(digit_places)))){
if (length(digit_places) == 1){
if (digit_places == -1){
if (skip_last_digit){
stop('skip_last_digit while doing a last digit test: contradiction!')
}
}
}
}
}
#unpacking_rounding_column must be a string specifying a column name in the data
if (TRUE %in% (!(is.na(unpacking_rounding_column)))){
if (!(is.character(unpacking_rounding_column))){
stop('unpacking_rounding_column must be a string specifying a column name in the data!')
}
}
#min_length must be an integer >= 2 denoting the minimum length of the numbers to be analyzed in digit pair test
if (TRUE %in% (!(is.na(min_length)))){
if (length(min_length) != 1){
stop("min_length must be an integer >= 2 denoting the minimum length of the numbers to be analyzed in digit pair test!")
}
else if (!(is.numeric(min_length))){
stop("min_length must be an integer >= 2 denoting the minimum length of the numbers to be analyzed in digit pair test!")
}
}
#duplicate_matching_cols must be a single column name or an array of column names to define a exact duplicate
if (TRUE %in% (!(is.na(duplicate_matching_cols)))){
if (duplicate_matching_cols != 'all'){
if (!(is.character(duplicate_matching_cols))){
stop("duplicate_matching_cols must be a single column name or an array of column names to define a exact duplicate!")
}
}
}
#sector_column must be a string specifying a column name in the data
if (TRUE %in% (!(is.na(sector_column)))){
if (!(is.character(sector_column))){
stop('sector_column must be a string specifying a column name in the data!')
}
}
#sector_grouping must be a list specifying the columns in each sector intended to split upo
if (TRUE %in% (!(is.na(sector_grouping)))){
if (!(is.list(sector_grouping))){
stop('sector_grouping must be a list specifying the columns in each sector intended to split upon!')
}
}
# need add this option later
# #"failure_factor must be an integer denoting the factor that one must exceed the other sector to be categorized as failure of the sector test
# if (TRUE %in% (!(is.na(failure_factor)))){
#   if (length(failure_factor) != 1){
#     stop("failure_factor must be an integer denoting the factor that one must exceed the other sector to be categorized as failure of the sector test!")
#   }
#   else if (!(is.numeric(failure_factor))){
#     stop("failure_factor must be an integer denoting the factor that one must exceed the other sector to be categorized as failure of the sector test!")
#   }
# }
#high must be a single digit place integer or an array of digit places specifying the digits that are classified as high digits
if (TRUE %in% (!(is.na(high)))){
if (!(is.numeric(high))){
stop("high must be a single digit place integer or an array of digit places specifying the digits that are classified as high digits!")
}
}
#########################################################
##########add the 05 option testing for rounding test
#########################################################
#max_length must be an integer denoting the maximum length of the numbers to be analyzed in padding test
if (TRUE %in% (!(is.na(max_length)))){
if (length(max_length) != 1){
stop("max_length must be an integer denoting the maximum length of the numbers to be analyzed in padding test!")
}
else if (!(is.numeric(max_length))){
stop("max_length must be an integer denoting the maximum length of the numbers to be analyzed in padding test!")
}
}
#num_digits must be an integer denoting the number of digits from the right to be to be analyzed in padding test
if (TRUE %in% (!(is.na(num_digits)))){
if (length(num_digits) != 1){
stop("num_digits must be an integer denoting the number of digits from the right to be to be analyzed in padding test!")
}
else if (!(is.numeric(num_digits))){
stop("num_digits must be an integer denoting the number of digits from the right to be to be analyzed in padding test!")
}
}
#N must be an integer denoting the number of datasets to be stimulated from Monte Carlo Process in padding test
if (TRUE %in% (!(is.na(N)))){
if (length(N) != 1){
stop("N must be an integer denoting the number of datasets to be stimulated from Monte Carlo Process in padding test!")
}
else if (!(is.numeric(N))){
stop("N must be an integer denoting the number of datasets to be stimulated from Monte Carlo Process in padding test!")
}
}
}
############################################################
#Testing; run the functions
#Wenjun Chang
#Summer 2020
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
#force numerical representation rather than scientific
#options(scipen = 999)
options(scipen = 1)
options(digits = 2)
##############################
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load chi square test GOF functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\chi_square_goodness_of_fit_functions.R')
#load main function for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_main_function.R')
#load functionS for unpack round numbers test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\unpack_round_numbers_test.R')
#load all functions for digit pair test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\digit_pair_test.R')
#load all functions for rounding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\rounding_test.R')
#load all functions for repeat test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\repeat_test.R')
#load all functions for high low test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\high_low_test.R')
#load all functions for padding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\padding_test.R')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function')
#############################################################
#############try it with given data##########################
#############################################################
#test data input and benford table functions
#load data input functions
data_columns = c("ALEXP","BENTOT", "BENM", "BENF")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
test = read.csv('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL 2.csv', stringsAsFactors=FALSE)
omitting_index = which(is.na(test$ALEXP.Values))
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
omitting_index
DigitData_match = DigitData
DigitData_match@cleaned = DigitData_match@cleaned[-omitting_index, ]
DigitData_match@numbers = DigitData_match@numbers[-omitting_index, ]
DigitData_match@left_aligned = DigitData_match@left_aligned[-omitting_index, ]
DigitData_match@right_aligned = DigitData_match@right_aligned[-omitting_index, ]
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
#test all digits test
data_columns = 'ALEXP'
digit_places =  'all'# c(1,2,3)
skip_first_digit=TRUE
omit_05 = c(0,5)
break_out='DIST'
# distribution='Benford'
# plot=TRUE
skip_last_digit=FALSE
#match the data with Jetson's
result = all_digits_test(digitdata = a, contingency_table = contingency_table, data_columns = data_columns, digit_places = digit_places,
skip_first_digit = skip_first_digit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE, skip_last_digit = skip_last_digit)
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function.R')
#############################################################
#############try it with given data##########################
#############################################################
#test data input and benford table functions
#load data input functions
data_columns = c("ALEXP","BENTOT", "BENM", "BENF")
fp = 'C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL.csv'
test = read.csv('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\ARID MASTER FINAL 2.csv', stringsAsFactors=FALSE)
omitting_index = which(is.na(test$ALEXP.Values))
DigitData = make_class(filepath = fp, col_analyzing = data_columns)
omitting_index
DigitData_match = DigitData
DigitData_match@cleaned = DigitData_match@cleaned[-omitting_index, ]
DigitData_match@numbers = DigitData_match@numbers[-omitting_index, ]
DigitData_match@left_aligned = DigitData_match@left_aligned[-omitting_index, ]
DigitData_match@right_aligned = DigitData_match@right_aligned[-omitting_index, ]
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
#test all digits test
data_columns = 'ALEXP'
digit_places =  'all'# c(1,2,3)
skip_first_digit=TRUE
omit_05 = c(0,5)
break_out='DIST'
# distribution='Benford'
# plot=TRUE
skip_last_digit=FALSE
#match the data with Jetson's
result = all_digits_test(digitdata = a, contingency_table = contingency_table, data_columns = data_columns, digit_places = digit_places,
skip_first_digit = skip_first_digit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE, skip_last_digit = skip_last_digit)
a='x'
#match the data with Jetson's
result = all_digits_test(digitdata = a, contingency_table = contingency_table, data_columns = data_columns, digit_places = digit_places,
skip_first_digit = skip_first_digit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE, skip_last_digit = skip_last_digit)
#match the data with Jetson's
result = all_digits_test(digitdata = DigitData_match, contingency_table = contingency_table, data_columns = data_columns, digit_places = digit_places,
skip_first_digit = skip_first_digit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=1, skip_last_digit = skip_last_digit)
#match the data with Jetson's
result = all_digits_test(digitdata = DigitData_match, contingency_table = contingency_table, data_columns = data_columns, digit_places = c('sxxs'),
skip_first_digit = skip_first_digit, omit_05 = omit_05, break_out=break_out, distribution='Benford', plot=TRUE, skip_last_digit = skip_last_digit)
tryCatch(2+'2',
error = function(e){
message("An error occurred:\n", e)
},
warning = function(w){
message("A warning occured:\n", w)
},
finally = {
message("Finally done!")
})
# contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
# contingency_table = contingency_table[!colnames(contingency_table) %in% c('a', 'X')]
# contingency_table
# saveRDS(contingency_table, file = "benford_table.RData")
readRDS(file = "benford_table.RData")
load("C:/Users/happy/OneDrive - California Institute of Technology/Desktop/digitanalysis/Rdigitanalysis/benford_table.RData")
# contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
# contingency_table = contingency_table[!colnames(contingency_table) %in% c('a', 'X')]
# contingency_table
# saveRDS(contingency_table, file = "benford_table.RData")
readRDS(file = "benford_table.RData")
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
contingency_table = contingency_table[!colnames(contingency_table) %in% c('a', 'X')]
contingency_table
############################################################
#Testing; run the functions
#Wenjun Chang
#Summer 2020
############################################################
#############prelim############
#clear workspace
rm(list = ls())
#free up R memory
gc()
#force numerical representation rather than scientific
#options(scipen = 999)
options(scipen = 1)
options(digits = 2)
##############################
#load data input functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\data_input_functions.R')
#load functions for computing Benford table
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\Benford_table_functions.R')
#load helper functions for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_helper_functions.R')
#load chi square test GOF functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\chi_square_goodness_of_fit_functions.R')
#load main function for all digit test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\all_digit_test_main_function.R')
#load functionS for unpack round numbers test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\unpack_round_numbers_test.R')
#load all functions for digit pair test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\digit_pair_test.R')
#load all functions for rounding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\rounding_test.R')
#load all functions for repeat test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\repeat_test.R')
#load all functions for high low test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\high_low_test.R')
#load all functions for padding test
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\padding_test.R')
#load all plotting functions
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\plotting_functions.R')
#load input check function
source('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\Rdigitanalysis\\R\\input_check_function.R')
contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
contingency_table = contingency_table[!colnames(contingency_table) %in% c('a', 'X')]
contingency_table
saveRDS(contingency_table, file = "benford_table.RData")
readRDS(file = "benford_table.RData")
# contingency_table = load_Benford_table('C:\\Users\\happy\\OneDrive - California Institute of Technology\\Desktop\\digitanalysis\\contingency_table.csv')
# contingency_table = contingency_table[!colnames(contingency_table) %in% c('a', 'X')]
# contingency_table
# saveRDS(contingency_table, file = "benford_table.RData")
readRDS(file = "benford_table.RData")
